"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleMerkleTree = exports.formatLeaf = void 0;
const abi_utils_1 = require("@metamask/abi-utils");
const bytes_1 = require("./bytes");
const core_1 = require("./core");
const merkletree_1 = require("./merkletree");
const errors_1 = require("./utils/errors");
function formatLeaf(value) {
    return (0, bytes_1.toHex)((0, abi_utils_1.encode)(['bytes32'], [value]));
}
exports.formatLeaf = formatLeaf;
class SimpleMerkleTree extends merkletree_1.MerkleTreeImpl {
    static of(values, options = {}) {
        const [tree, indexedValues] = merkletree_1.MerkleTreeImpl.prepare(values, options, formatLeaf, options.nodeHash);
        return new SimpleMerkleTree(tree, indexedValues, formatLeaf, options.nodeHash);
    }
    static load(data, nodeHash) {
        (0, errors_1.validateArgument)(data.format === 'simple-v1', `Unknown format '${data.format}'`);
        (0, errors_1.validateArgument)((nodeHash == undefined) !== (data.hash == 'custom'), nodeHash ? 'Data does not expect a custom node hashing function' : 'Data expects a custom node hashing function');
        const tree = new SimpleMerkleTree(data.tree, data.values, formatLeaf, nodeHash);
        tree.validate();
        return tree;
    }
    static verify(root, leaf, proof, nodeHash) {
        return (0, bytes_1.toHex)(root) === (0, core_1.processProof)(formatLeaf(leaf), proof, nodeHash);
    }
    static verifyMultiProof(root, multiproof, nodeHash) {
        return (0, bytes_1.toHex)(root) === (0, core_1.processMultiProof)(multiproof, nodeHash);
    }
    dump() {
        return {
            format: 'simple-v1',
            tree: this.tree,
            values: this.values.map(({ value, treeIndex }) => ({ value: (0, bytes_1.toHex)(value), treeIndex })),
            ...(this.nodeHash ? { hash: 'custom' } : {}),
        };
    }
}
exports.SimpleMerkleTree = SimpleMerkleTree;
//# sourceMappingURL=simple.js.map