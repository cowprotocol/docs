import { ParamType, defaultAbiCoder, Interface } from '@ethersproject/abi';
import { getStatic, defineReadOnly } from '@ethersproject/properties';
import { hexDataSlice, hexConcat } from '@ethersproject/bytes';

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function isValue(arg) {
  return arg.param !== undefined;
}

var LiteralValue = function LiteralValue(param, value) {
  this.param = param;
  this.value = value;
};

var ReturnValue = function ReturnValue(param, command) {
  this.param = param;
  this.command = command;
};

var StateValue = function StateValue() {
  this.param = ParamType.from('bytes[]');
};

var SubplanValue = function SubplanValue(planner) {
  this.param = ParamType.from('bytes[]');
  this.planner = planner;
};

var CommandFlags;

(function (CommandFlags) {
  CommandFlags[CommandFlags["DELEGATECALL"] = 0] = "DELEGATECALL";
  CommandFlags[CommandFlags["CALL"] = 1] = "CALL";
  CommandFlags[CommandFlags["STATICCALL"] = 2] = "STATICCALL";
  CommandFlags[CommandFlags["CALL_WITH_VALUE"] = 3] = "CALL_WITH_VALUE";
  CommandFlags[CommandFlags["CALLTYPE_MASK"] = 3] = "CALLTYPE_MASK";
  CommandFlags[CommandFlags["EXTENDED_COMMAND"] = 64] = "EXTENDED_COMMAND";
  CommandFlags[CommandFlags["TUPLE_RETURN"] = 128] = "TUPLE_RETURN";
})(CommandFlags || (CommandFlags = {}));

var FunctionCall = /*#__PURE__*/function () {
  function FunctionCall(contract, flags, fragment, args, callvalue) {
    this.contract = contract;
    this.flags = flags;
    this.fragment = fragment;
    this.args = args;
    this.callvalue = callvalue;
  }

  var _proto = FunctionCall.prototype;

  _proto.withValue = function withValue(value) {
    if ((this.flags & CommandFlags.CALLTYPE_MASK) !== CommandFlags.CALL && (this.flags & CommandFlags.CALLTYPE_MASK) !== CommandFlags.CALL_WITH_VALUE) {
      throw new Error('Only CALL operations can send value');
    }

    return new FunctionCall(this.contract, this.flags & ~CommandFlags.CALLTYPE_MASK | CommandFlags.CALL_WITH_VALUE, this.fragment, this.args, encodeArg(value, ParamType.from('uint')));
  };

  _proto.rawValue = function rawValue() {
    return new FunctionCall(this.contract, this.flags | CommandFlags.TUPLE_RETURN, this.fragment, this.args, this.callvalue);
  };

  _proto.staticcall = function staticcall() {
    if ((this.flags & CommandFlags.CALLTYPE_MASK) !== CommandFlags.CALL) {
      throw new Error('Only CALL operations can be made static');
    }

    return new FunctionCall(this.contract, this.flags & ~CommandFlags.CALLTYPE_MASK | CommandFlags.STATICCALL, this.fragment, this.args, this.callvalue);
  };

  return FunctionCall;
}();
function isDynamicType(param) {
  if (typeof param === 'undefined') return false;
  return ['string', 'bytes', 'array', 'tuple'].includes(param.baseType);
}

function abiEncodeSingle(param, value) {
  if (isDynamicType(param)) {
    return new LiteralValue(param, hexDataSlice(defaultAbiCoder.encode([param], [value]), 32));
  }

  return new LiteralValue(param, defaultAbiCoder.encode([param], [value]));
}

function encodeArg(arg, param) {
  if (isValue(arg)) {
    if (arg.param.type !== param.type) {
      // Todo: type casting rules
      throw new Error("Cannot pass value of type " + arg.param.type + " to input of type " + param.type);
    }

    return arg;
  } else if (arg instanceof Planner) {
    return new SubplanValue(arg);
  } else {
    return abiEncodeSingle(param, arg);
  }
}

function buildCall(contract, fragment) {
  return function call() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length !== fragment.inputs.length) {
      throw new Error("Function " + fragment.name + " has " + fragment.inputs.length + " arguments but " + args.length + " provided");
    }

    var encodedArgs = args.map(function (arg, idx) {
      return encodeArg(arg, fragment.inputs[idx]);
    });
    return new FunctionCall(contract, contract.commandflags, fragment, encodedArgs);
  };
}

var BaseContract = /*#__PURE__*/function () {
  function BaseContract(address, contractInterface, commandflags) {
    var _this = this;

    this["interface"] = getStatic(this instanceof BaseContract ? this.constructor : void 0, 'getInterface')(contractInterface);

    if ((commandflags & ~CommandFlags.CALLTYPE_MASK) !== 0) {
      throw new Error('Only calltype flags may be supplied to BaseContract constructor');
    }

    this.address = address;
    this.commandflags = commandflags;
    this.functions = {};
    var uniqueNames = {};
    var uniqueSignatures = {};
    Object.keys(this["interface"].functions).forEach(function (signature) {
      var fragment = _this["interface"].functions[signature]; // Check that the signature is unique; if not the ABI generation has
      // not been cleaned or may be incorrectly generated

      if (uniqueSignatures[signature]) {
        throw new Error("Duplicate ABI entry for " + JSON.stringify(signature));
      }

      uniqueSignatures[signature] = true; // Track unique names; we only expose bare named functions if they
      // are ambiguous

      {
        var name = fragment.name;

        if (!uniqueNames[name]) {
          uniqueNames[name] = [];
        }

        uniqueNames[name].push(signature);
      }

      if (_this[signature] == null) {
        defineReadOnly(_this, signature, buildCall(_this, fragment));
      } // We do not collapse simple calls on this bucket, which allows
      // frameworks to safely use this without introspection as well as
      // allows decoding error recovery.


      if (_this.functions[signature] == null) {
        defineReadOnly(_this.functions, signature, buildCall(_this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach(function (name) {
      // Ambiguous names to not get attached as bare names
      var signatures = uniqueNames[name];

      if (signatures.length > 1) {
        return;
      }

      var signature = signatures[0]; // If overwriting a member property that is null, swallow the error

      try {
        if (_this[name] == null) {
          defineReadOnly(_this, name, _this[signature]);
        }
      } catch (e) {}

      if (_this.functions[name] == null) {
        defineReadOnly(_this.functions, name, _this.functions[signature]);
      }
    });
  }

  BaseContract.createContract = function createContract(contract, commandflags) {
    if (commandflags === void 0) {
      commandflags = CommandFlags.CALL;
    }

    return new Contract(contract.address, contract["interface"], commandflags);
  };

  BaseContract.createLibrary = function createLibrary(contract) {
    return new Contract(contract.address, contract["interface"], CommandFlags.DELEGATECALL);
  };

  BaseContract.getInterface = function getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }

    return new Interface(contractInterface);
  };

  return BaseContract;
}();

var Contract = /*#__PURE__*/function (_BaseContract) {
  _inheritsLoose(Contract, _BaseContract);

  function Contract() {
    return _BaseContract.apply(this, arguments) || this;
  }

  return Contract;
}(BaseContract);
var CommandType;

(function (CommandType) {
  CommandType[CommandType["CALL"] = 0] = "CALL";
  CommandType[CommandType["RAWCALL"] = 1] = "RAWCALL";
  CommandType[CommandType["SUBPLAN"] = 2] = "SUBPLAN";
})(CommandType || (CommandType = {}));

var Command = function Command(call, type) {
  this.call = call;
  this.type = type;
};

function padArray(a, len, value) {
  return a.concat(new Array(len - a.length).fill(value));
}

var Planner = /*#__PURE__*/function () {
  function Planner() {
    this.state = new StateValue();
    this.commands = [];
  }

  var _proto2 = Planner.prototype;

  _proto2.add = function add(call) {
    var _call$fragment$output;

    var command = new Command(call, CommandType.CALL);
    this.commands.push(command);

    for (var _iterator = _createForOfIteratorHelperLoose(call.args), _step; !(_step = _iterator()).done;) {
      var arg = _step.value;

      if (arg instanceof SubplanValue) {
        throw new Error('Only subplans can have arguments of type SubplanValue');
      }
    }

    if (call.flags & CommandFlags.TUPLE_RETURN) {
      return new ReturnValue(ParamType.fromString('bytes'), command);
    }

    if (((_call$fragment$output = call.fragment.outputs) == null ? void 0 : _call$fragment$output.length) !== 1) {
      return null;
    }

    return new ReturnValue(call.fragment.outputs[0], command);
  };

  _proto2.addSubplan = function addSubplan(call) {
    var _call$fragment$output2;

    var hasSubplan = false;
    var hasState = false;

    for (var _iterator2 = _createForOfIteratorHelperLoose(call.args), _step2; !(_step2 = _iterator2()).done;) {
      var arg = _step2.value;

      if (arg instanceof SubplanValue) {
        if (hasSubplan) {
          throw new Error('Subplans can only take one planner argument');
        }

        hasSubplan = true;
      }

      if (arg instanceof StateValue) {
        if (hasState) {
          throw new Error('Subplans can only take one state argument');
        }

        hasState = true;
      }
    }

    if (!hasSubplan || !hasState) {
      throw new Error('Subplans must take planner and state arguments');
    }

    if (!hasSubplan || !hasState) {
      throw new Error('Subplans must take planner and state arguments');
    }

    if (((_call$fragment$output2 = call.fragment.outputs) == null ? void 0 : _call$fragment$output2.length) === 1 && call.fragment.outputs[0].type !== 'bytes[]') {
      throw new Error('Subplans must return a bytes[] replacement state or nothing');
    }

    this.commands.push(new Command(call, CommandType.SUBPLAN));
  };

  _proto2.replaceState = function replaceState(call) {
    var _call$fragment$output3;

    if (((_call$fragment$output3 = call.fragment.outputs) == null ? void 0 : _call$fragment$output3.length) !== 1 || call.fragment.outputs[0].type !== 'bytes[]') {
      throw new Error('Function replacing state must return a bytes[]');
    }

    this.commands.push(new Command(call, CommandType.RAWCALL));
  };

  _proto2.preplan = function preplan(commandVisibility, literalVisibility, seen, planners) {
    if (seen === undefined) {
      seen = new Set();
    }

    if (planners === undefined) {
      planners = new Set();
    }

    if (planners.has(this)) {
      throw new Error('A planner cannot contain itself');
    }

    planners.add(this); // Build visibility maps

    for (var _iterator3 = _createForOfIteratorHelperLoose(this.commands), _step3; !(_step3 = _iterator3()).done;) {
      var command = _step3.value;
      var inargs = command.call.args;

      if ((command.call.flags & CommandFlags.CALLTYPE_MASK) === CommandFlags.CALL_WITH_VALUE) {
        if (!command.call.callvalue) {
          throw new Error('Call with value must have a value parameter');
        }

        inargs = [command.call.callvalue].concat(inargs);
      }

      for (var _iterator4 = _createForOfIteratorHelperLoose(inargs), _step4; !(_step4 = _iterator4()).done;) {
        var arg = _step4.value;

        if (arg instanceof ReturnValue) {
          if (!seen.has(arg.command)) {
            throw new Error("Return value from \"" + arg.command.call.fragment.name + "\" is not visible here");
          }

          commandVisibility.set(arg.command, command);
        } else if (arg instanceof LiteralValue) {
          literalVisibility.set(arg.value, command);
        } else if (arg instanceof SubplanValue) {
          var subplanSeen = seen;

          if (!command.call.fragment.outputs || command.call.fragment.outputs.length === 0) {
            // Read-only subplan; return values aren't visible externally
            subplanSeen = new Set(seen);
          }

          arg.planner.preplan(commandVisibility, literalVisibility, subplanSeen, planners);
        } else if (!(arg instanceof StateValue)) {
          throw new Error("Unknown function argument type '" + typeof arg + "'");
        }
      }

      seen.add(command);
    }

    return {
      commandVisibility: commandVisibility,
      literalVisibility: literalVisibility
    };
  };

  _proto2.buildCommandArgs = function buildCommandArgs(command, returnSlotMap, literalSlotMap, state) {
    // Build a list of argument value indexes
    var inargs = command.call.args;

    if ((command.call.flags & CommandFlags.CALLTYPE_MASK) === CommandFlags.CALL_WITH_VALUE) {
      if (!command.call.callvalue) {
        throw new Error('Call with value must have a value parameter');
      }

      inargs = [command.call.callvalue].concat(inargs);
    }

    var args = new Array();
    inargs.forEach(function (arg) {
      var slot;

      if (arg instanceof ReturnValue) {
        slot = returnSlotMap.get(arg.command);
      } else if (arg instanceof LiteralValue) {
        slot = literalSlotMap.get(arg.value);
      } else if (arg instanceof StateValue) {
        slot = 0xfe;
      } else if (arg instanceof SubplanValue) {
        // buildCommands has already built the subplan and put it in the last state slot
        slot = state.length - 1;
      } else {
        throw new Error("Unknown function argument type '" + typeof arg + "'");
      }

      if (isDynamicType(arg.param)) {
        slot |= 0x80;
      }

      args.push(slot);
    });
    return args;
  };

  _proto2.buildCommands = function buildCommands(ps) {
    var encodedCommands = new Array(); // Build commands, and add state entries as needed

    for (var _iterator5 = _createForOfIteratorHelperLoose(this.commands), _step5; !(_step5 = _iterator5()).done;) {
      var command = _step5.value;

      if (command.type === CommandType.SUBPLAN) {
        // Find the subplan
        var subplanner = command.call.args.find(function (arg) {
          return arg instanceof SubplanValue;
        }).planner; // Build a list of commands

        var subcommands = subplanner.buildCommands(ps); // Encode them and push them to a new state slot

        ps.state.push(hexDataSlice(defaultAbiCoder.encode(['bytes32[]'], [subcommands]), 32)); // The slot is no longer needed after this command

        ps.freeSlots.push(ps.state.length - 1);
      }

      var flags = command.call.flags;
      var args = this.buildCommandArgs(command, ps.returnSlotMap, ps.literalSlotMap, ps.state);

      if (args.length > 6) {
        flags |= CommandFlags.EXTENDED_COMMAND;
      } // Add any newly unused state slots to the list


      ps.freeSlots = ps.freeSlots.concat(ps.stateExpirations.get(command) || []); // Figure out where to put the return value

      var ret = 0xff;

      if (ps.commandVisibility.has(command)) {
        var _command$call$fragmen;

        if (command.type === CommandType.RAWCALL || command.type === CommandType.SUBPLAN) {
          throw new Error("Return value of " + command.call.fragment.name + " cannot be used to replace state and in another function");
        }

        ret = ps.state.length;

        if (ps.freeSlots.length > 0) {
          ret = ps.freeSlots.pop();
        } // Store the slot mapping


        ps.returnSlotMap.set(command, ret); // Make the slot available when it's not needed

        var expiryCommand = ps.commandVisibility.get(command);
        ps.stateExpirations.set(expiryCommand, (ps.stateExpirations.get(expiryCommand) || []).concat([ret]));

        if (ret === ps.state.length) {
          ps.state.push('0x');
        }

        if (isDynamicType((_command$call$fragmen = command.call.fragment.outputs) == null ? void 0 : _command$call$fragmen[0]) || (command.call.flags & CommandFlags.TUPLE_RETURN) !== 0) {
          ret |= 0x80;
        }
      } else if (command.type === CommandType.RAWCALL || command.type === CommandType.SUBPLAN) {
        if (command.call.fragment.outputs && command.call.fragment.outputs.length === 1) {
          ret = 0xfe;
        }
      }

      if ((flags & CommandFlags.EXTENDED_COMMAND) === CommandFlags.EXTENDED_COMMAND) {
        // Extended command
        encodedCommands.push(hexConcat([command.call.contract["interface"].getSighash(command.call.fragment), [flags, 0, 0, 0, 0, 0, 0, ret], command.call.contract.address]));
        encodedCommands.push(hexConcat([padArray(args, 32, 0xff)]));
      } else {
        // Standard command
        encodedCommands.push(hexConcat([command.call.contract["interface"].getSighash(command.call.fragment), [flags], padArray(args, 6, 0xff), [ret], command.call.contract.address]));
      }
    }

    return encodedCommands;
  };

  _proto2.plan = function plan() {
    // Tracks the last time a literal is used in the program
    var literalVisibility = new Map(); // Tracks the last time a command's output is used in the program

    var commandVisibility = new Map();
    this.preplan(commandVisibility, literalVisibility); // Maps from commands to the slots that expire on execution (if any)

    var stateExpirations = new Map(); // Tracks the state slot each literal is stored in

    var literalSlotMap = new Map();
    var state = new Array(); // Prepopulate the state and state expirations with literals

    literalVisibility.forEach(function (lastCommand, literal) {
      var slot = state.length;
      state.push(literal);
      literalSlotMap.set(literal, slot);
      stateExpirations.set(lastCommand, (stateExpirations.get(lastCommand) || []).concat([slot]));
    });
    var ps = {
      returnSlotMap: new Map(),
      literalSlotMap: literalSlotMap,
      freeSlots: new Array(),
      stateExpirations: stateExpirations,
      commandVisibility: commandVisibility,
      state: state
    };
    var encodedCommands = this.buildCommands(ps);
    return {
      commands: encodedCommands,
      state: state
    };
  };

  return Planner;
}();

export { Contract, FunctionCall, Planner };
//# sourceMappingURL=weiroll.js.esm.js.map
