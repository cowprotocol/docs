import { ContractInterface } from '@ethersproject/contracts';
import type { Contract as EthersContract } from '@ethersproject/contracts';
import { Interface, ParamType } from '@ethersproject/abi';
import type { FunctionFragment } from '@ethersproject/abi';
export interface Value {
    readonly param: ParamType;
}
declare class ReturnValue implements Value {
    readonly param: ParamType;
    readonly command: Command;
    constructor(param: ParamType, command: Command);
}
declare class StateValue implements Value {
    readonly param: ParamType;
    constructor();
}
export declare enum CommandFlags {
    DELEGATECALL = 0,
    CALL = 1,
    STATICCALL = 2,
    CALL_WITH_VALUE = 3,
    CALLTYPE_MASK = 3,
    EXTENDED_COMMAND = 64,
    TUPLE_RETURN = 128
}
export declare class FunctionCall {
    readonly contract: Contract;
    readonly flags: CommandFlags;
    readonly fragment: FunctionFragment;
    readonly args: Value[];
    readonly callvalue?: Value;
    constructor(contract: Contract, flags: CommandFlags, fragment: FunctionFragment, args: Value[], callvalue?: Value);
    withValue(value: Value): FunctionCall;
    rawValue(): FunctionCall;
    staticcall(): FunctionCall;
}
export declare type ContractFunction = (...args: Array<any>) => FunctionCall;
export declare function isDynamicType(param?: ParamType): boolean;
declare class BaseContract {
    readonly address: string;
    readonly commandflags: CommandFlags;
    readonly interface: Interface;
    readonly functions: {
        [name: string]: ContractFunction;
    };
    constructor(address: string, contractInterface: ContractInterface, commandflags: CommandFlags);
    static createContract(contract: EthersContract, commandflags?: CommandFlags): Contract;
    static createLibrary(contract: EthersContract): Contract;
    static getInterface(contractInterface: ContractInterface): Interface;
}
export declare class Contract extends BaseContract {
    readonly [key: string]: ContractFunction | any;
}
declare enum CommandType {
    CALL = 0,
    RAWCALL = 1,
    SUBPLAN = 2
}
declare class Command {
    readonly call: FunctionCall;
    readonly type: CommandType;
    constructor(call: FunctionCall, type: CommandType);
}
export declare class Planner {
    readonly state: StateValue;
    commands: Command[];
    constructor();
    add(call: FunctionCall): ReturnValue | null;
    addSubplan(call: FunctionCall): void;
    replaceState(call: FunctionCall): void;
    private preplan;
    private buildCommandArgs;
    private buildCommands;
    plan(): {
        commands: string[];
        state: string[];
    };
}
export {};
