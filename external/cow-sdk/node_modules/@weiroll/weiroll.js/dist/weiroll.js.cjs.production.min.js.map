{"version":3,"file":"weiroll.js.cjs.production.min.js","sources":["../src/planner.ts"],"sourcesContent":["import { ContractInterface } from '@ethersproject/contracts';\nimport type { Contract as EthersContract } from '@ethersproject/contracts';\nimport { Interface, ParamType, defaultAbiCoder } from '@ethersproject/abi';\nimport type { FunctionFragment } from '@ethersproject/abi';\nimport { defineReadOnly, getStatic } from '@ethersproject/properties';\nimport { hexConcat, hexDataSlice } from '@ethersproject/bytes';\n\nexport interface Value {\n  readonly param: ParamType;\n}\n\nfunction isValue(arg: any): arg is Value {\n  return (arg as Value).param !== undefined;\n}\n\nclass LiteralValue implements Value {\n  readonly param: ParamType;\n  readonly value: string;\n\n  constructor(param: ParamType, value: string) {\n    this.param = param;\n    this.value = value;\n  }\n}\n\nclass ReturnValue implements Value {\n  readonly param: ParamType;\n  readonly command: Command; // Function call we want the return value of\n\n  constructor(param: ParamType, command: Command) {\n    this.param = param;\n    this.command = command;\n  }\n}\n\nclass StateValue implements Value {\n  readonly param: ParamType;\n\n  constructor() {\n    this.param = ParamType.from('bytes[]');\n  }\n}\n\nclass SubplanValue implements Value {\n  readonly param: ParamType;\n  readonly planner: Planner;\n\n  constructor(planner: Planner) {\n    this.param = ParamType.from('bytes[]');\n    this.planner = planner;\n  }\n}\n\nexport enum CommandFlags {\n  DELEGATECALL = 0x00,\n  CALL = 0x01,\n  STATICCALL = 0x02,\n  CALL_WITH_VALUE = 0x03,\n  CALLTYPE_MASK = 0x03,\n  EXTENDED_COMMAND = 0x40,\n  TUPLE_RETURN = 0x80,\n}\n\nexport class FunctionCall {\n  readonly contract: Contract;\n  readonly flags: CommandFlags;\n  readonly fragment: FunctionFragment;\n  readonly args: Value[];\n  readonly callvalue?: Value;\n\n  constructor(\n    contract: Contract,\n    flags: CommandFlags,\n    fragment: FunctionFragment,\n    args: Value[],\n    callvalue?: Value\n  ) {\n    this.contract = contract;\n    this.flags = flags;\n    this.fragment = fragment;\n    this.args = args;\n    this.callvalue = callvalue;\n  }\n\n  withValue(value: Value): FunctionCall {\n    if (\n      (this.flags & CommandFlags.CALLTYPE_MASK) !== CommandFlags.CALL &&\n      (this.flags & CommandFlags.CALLTYPE_MASK) !== CommandFlags.CALL_WITH_VALUE\n    ) {\n      throw new Error('Only CALL operations can send value');\n    }\n    return new FunctionCall(\n      this.contract,\n      (this.flags & ~CommandFlags.CALLTYPE_MASK) | CommandFlags.CALL_WITH_VALUE,\n      this.fragment,\n      this.args,\n      encodeArg(value, ParamType.from('uint'))\n    );\n  }\n\n  rawValue(): FunctionCall {\n    return new FunctionCall(\n      this.contract,\n      this.flags | CommandFlags.TUPLE_RETURN,\n      this.fragment,\n      this.args,\n      this.callvalue\n    );\n  }\n\n  staticcall(): FunctionCall {\n    if ((this.flags & CommandFlags.CALLTYPE_MASK) !== CommandFlags.CALL) {\n      throw new Error('Only CALL operations can be made static');\n    }\n    return new FunctionCall(\n      this.contract,\n      (this.flags & ~CommandFlags.CALLTYPE_MASK) | CommandFlags.STATICCALL,\n      this.fragment,\n      this.args,\n      this.callvalue\n    );\n  }\n}\n\nexport type ContractFunction = (...args: Array<any>) => FunctionCall;\n\nexport function isDynamicType(param?: ParamType): boolean {\n  if (typeof param === 'undefined') return false;\n\n  return ['string', 'bytes', 'array', 'tuple'].includes(param.baseType);\n}\n\nfunction abiEncodeSingle(param: ParamType, value: any): LiteralValue {\n  if (isDynamicType(param)) {\n    return new LiteralValue(\n      param,\n      hexDataSlice(defaultAbiCoder.encode([param], [value]), 32)\n    );\n  }\n  return new LiteralValue(param, defaultAbiCoder.encode([param], [value]));\n}\n\nfunction encodeArg(arg: any, param: ParamType): Value {\n  if (isValue(arg)) {\n    if (arg.param.type !== param.type) {\n      // Todo: type casting rules\n      throw new Error(\n        `Cannot pass value of type ${arg.param.type} to input of type ${param.type}`\n      );\n    }\n    return arg;\n  } else if (arg instanceof Planner) {\n    return new SubplanValue(arg);\n  } else {\n    return abiEncodeSingle(param, arg);\n  }\n}\n\nfunction buildCall(\n  contract: Contract,\n  fragment: FunctionFragment\n): ContractFunction {\n  return function call(...args: Array<any>): FunctionCall {\n    if (args.length !== fragment.inputs.length) {\n      throw new Error(\n        `Function ${fragment.name} has ${fragment.inputs.length} arguments but ${args.length} provided`\n      );\n    }\n\n    const encodedArgs = args.map((arg, idx) =>\n      encodeArg(arg, fragment.inputs[idx])\n    );\n\n    return new FunctionCall(\n      contract,\n      contract.commandflags,\n      fragment,\n      encodedArgs\n    );\n  };\n}\n\nclass BaseContract {\n  readonly address: string;\n  readonly commandflags: CommandFlags;\n  readonly interface: Interface;\n  readonly functions: { [name: string]: ContractFunction };\n\n  constructor(\n    address: string,\n    contractInterface: ContractInterface,\n    commandflags: CommandFlags\n  ) {\n    this.interface = getStatic<\n      (contractInterface: ContractInterface) => Interface\n    >(\n      new.target,\n      'getInterface'\n    )(contractInterface);\n    if ((commandflags & ~CommandFlags.CALLTYPE_MASK) !== 0) {\n      throw new Error(\n        'Only calltype flags may be supplied to BaseContract constructor'\n      );\n    }\n\n    this.address = address;\n    this.commandflags = commandflags;\n    this.functions = {};\n\n    const uniqueNames: { [name: string]: Array<string> } = {};\n    const uniqueSignatures: { [signature: string]: boolean } = {};\n    Object.keys(this.interface.functions).forEach((signature) => {\n      const fragment = this.interface.functions[signature];\n\n      // Check that the signature is unique; if not the ABI generation has\n      // not been cleaned or may be incorrectly generated\n      if (uniqueSignatures[signature]) {\n        throw new Error(`Duplicate ABI entry for ${JSON.stringify(signature)}`);\n      }\n      uniqueSignatures[signature] = true;\n\n      // Track unique names; we only expose bare named functions if they\n      // are ambiguous\n      {\n        const name = fragment.name;\n        if (!uniqueNames[name]) {\n          uniqueNames[name] = [];\n        }\n        uniqueNames[name].push(signature);\n      }\n\n      if ((this as Contract)[signature] == null) {\n        defineReadOnly<any, any>(this, signature, buildCall(this, fragment));\n      }\n\n      // We do not collapse simple calls on this bucket, which allows\n      // frameworks to safely use this without introspection as well as\n      // allows decoding error recovery.\n      if (this.functions[signature] == null) {\n        defineReadOnly(this.functions, signature, buildCall(this, fragment));\n      }\n    });\n\n    Object.keys(uniqueNames).forEach((name) => {\n      // Ambiguous names to not get attached as bare names\n      const signatures = uniqueNames[name];\n      if (signatures.length > 1) {\n        return;\n      }\n\n      const signature = signatures[0];\n\n      // If overwriting a member property that is null, swallow the error\n      try {\n        if ((this as Contract)[name] == null) {\n          defineReadOnly(this as Contract, name, (this as Contract)[signature]);\n        }\n      } catch (e) {}\n\n      if (this.functions[name] == null) {\n        defineReadOnly(this.functions, name, this.functions[signature]);\n      }\n    });\n  }\n\n  static createContract(\n    contract: EthersContract,\n    commandflags = CommandFlags.CALL\n  ): Contract {\n    return new Contract(contract.address, contract.interface, commandflags);\n  }\n\n  static createLibrary(contract: EthersContract): Contract {\n    return new Contract(\n      contract.address,\n      contract.interface,\n      CommandFlags.DELEGATECALL\n    );\n  }\n\n  static getInterface(contractInterface: ContractInterface): Interface {\n    if (Interface.isInterface(contractInterface)) {\n      return contractInterface;\n    }\n    return new Interface(contractInterface);\n  }\n}\n\nexport class Contract extends BaseContract {\n  // The meta-class properties\n  readonly [key: string]: ContractFunction | any;\n}\n\nenum CommandType {\n  CALL,\n  RAWCALL,\n  SUBPLAN,\n}\n\nclass Command {\n  readonly call: FunctionCall;\n  readonly type: CommandType;\n\n  constructor(call: FunctionCall, type: CommandType) {\n    this.call = call;\n    this.type = type;\n  }\n}\n\ninterface PlannerState {\n  // Maps from a command to the slot used for its return value\n  returnSlotMap: Map<Command, number>;\n  // Maps from a literal to the slot used to store it\n  literalSlotMap: Map<string, number>;\n  // An array of unused state slots\n  freeSlots: Array<number>;\n  // Maps from a command to the slots that expire when it's executed\n  stateExpirations: Map<Command, number[]>;\n  // Maps from a command to the last command that consumes its output\n  commandVisibility: Map<Command, Command>;\n  // The initial state array\n  state: Array<string>;\n}\n\nfunction padArray(a: Array<number>, len: number, value: number): Array<number> {\n  return a.concat(new Array<number>(len - a.length).fill(value));\n}\n\nexport class Planner {\n  readonly state: StateValue;\n  commands: Command[];\n\n  constructor() {\n    this.state = new StateValue();\n    this.commands = [];\n  }\n\n  add(call: FunctionCall): ReturnValue | null {\n    const command = new Command(call, CommandType.CALL);\n    this.commands.push(command);\n\n    for (const arg of call.args) {\n      if (arg instanceof SubplanValue) {\n        throw new Error(\n          'Only subplans can have arguments of type SubplanValue'\n        );\n      }\n    }\n\n    if (call.flags & CommandFlags.TUPLE_RETURN) {\n      return new ReturnValue(ParamType.fromString('bytes'), command);\n    }\n    if (call.fragment.outputs?.length !== 1) {\n      return null;\n    }\n    return new ReturnValue(call.fragment.outputs[0], command);\n  }\n\n  addSubplan(call: FunctionCall) {\n    let hasSubplan = false;\n    let hasState = false;\n    for (const arg of call.args) {\n      if (arg instanceof SubplanValue) {\n        if (hasSubplan) {\n          throw new Error('Subplans can only take one planner argument');\n        }\n        hasSubplan = true;\n      }\n      if (arg instanceof StateValue) {\n        if (hasState) {\n          throw new Error('Subplans can only take one state argument');\n        }\n        hasState = true;\n      }\n    }\n    if (!hasSubplan || !hasState) {\n      throw new Error('Subplans must take planner and state arguments');\n    }\n    if (!hasSubplan || !hasState) {\n      throw new Error('Subplans must take planner and state arguments');\n    }\n\n    if (\n      call.fragment.outputs?.length === 1 &&\n      call.fragment.outputs[0].type !== 'bytes[]'\n    ) {\n      throw new Error(\n        'Subplans must return a bytes[] replacement state or nothing'\n      );\n    }\n\n    this.commands.push(new Command(call, CommandType.SUBPLAN));\n  }\n\n  replaceState(call: FunctionCall) {\n    if (\n      call.fragment.outputs?.length !== 1 ||\n      call.fragment.outputs[0].type !== 'bytes[]'\n    ) {\n      throw new Error('Function replacing state must return a bytes[]');\n    }\n\n    this.commands.push(new Command(call, CommandType.RAWCALL));\n  }\n\n  private preplan(\n    commandVisibility: Map<Command, Command>,\n    literalVisibility: Map<string, Command>,\n    seen?: Set<Command>,\n    planners?: Set<Planner>\n  ) {\n    if (seen === undefined) {\n      seen = new Set<Command>();\n    }\n    if (planners === undefined) {\n      planners = new Set<Planner>();\n    }\n\n    if (planners.has(this)) {\n      throw new Error('A planner cannot contain itself');\n    }\n    planners.add(this);\n\n    // Build visibility maps\n    for (let command of this.commands) {\n      let inargs = command.call.args;\n      if (\n        (command.call.flags & CommandFlags.CALLTYPE_MASK) ===\n        CommandFlags.CALL_WITH_VALUE\n      ) {\n        if (!command.call.callvalue) {\n          throw new Error('Call with value must have a value parameter');\n        }\n        inargs = [command.call.callvalue].concat(inargs);\n      }\n\n      for (let arg of inargs) {\n        if (arg instanceof ReturnValue) {\n          if (!seen.has(arg.command)) {\n            throw new Error(\n              `Return value from \"${arg.command.call.fragment.name}\" is not visible here`\n            );\n          }\n          commandVisibility.set(arg.command, command);\n        } else if (arg instanceof LiteralValue) {\n          literalVisibility.set(arg.value, command);\n        } else if (arg instanceof SubplanValue) {\n          let subplanSeen = seen;\n          if (\n            !command.call.fragment.outputs ||\n            command.call.fragment.outputs.length === 0\n          ) {\n            // Read-only subplan; return values aren't visible externally\n            subplanSeen = new Set<Command>(seen);\n          }\n          arg.planner.preplan(\n            commandVisibility,\n            literalVisibility,\n            subplanSeen,\n            planners\n          );\n        } else if (!(arg instanceof StateValue)) {\n          throw new Error(`Unknown function argument type '${typeof arg}'`);\n        }\n      }\n      seen.add(command);\n    }\n\n    return { commandVisibility, literalVisibility };\n  }\n\n  private buildCommandArgs(\n    command: Command,\n    returnSlotMap: Map<Command, number>,\n    literalSlotMap: Map<string, number>,\n    state: Array<string>\n  ): Array<number> {\n    // Build a list of argument value indexes\n    let inargs = command.call.args;\n    if (\n      (command.call.flags & CommandFlags.CALLTYPE_MASK) ===\n      CommandFlags.CALL_WITH_VALUE\n    ) {\n      if (!command.call.callvalue) {\n        throw new Error('Call with value must have a value parameter');\n      }\n      inargs = [command.call.callvalue].concat(inargs);\n    }\n\n    const args = new Array<number>();\n    inargs.forEach((arg) => {\n      let slot: number;\n      if (arg instanceof ReturnValue) {\n        slot = returnSlotMap.get(arg.command) as number;\n      } else if (arg instanceof LiteralValue) {\n        slot = literalSlotMap.get(arg.value) as number;\n      } else if (arg instanceof StateValue) {\n        slot = 0xfe;\n      } else if (arg instanceof SubplanValue) {\n        // buildCommands has already built the subplan and put it in the last state slot\n        slot = state.length - 1;\n      } else {\n        throw new Error(`Unknown function argument type '${typeof arg}'`);\n      }\n      if (isDynamicType(arg.param)) {\n        slot |= 0x80;\n      }\n      args.push(slot);\n    });\n\n    return args;\n  }\n\n  private buildCommands(ps: PlannerState): Array<string> {\n    const encodedCommands = new Array<string>();\n    // Build commands, and add state entries as needed\n    for (let command of this.commands) {\n      if (command.type === CommandType.SUBPLAN) {\n        // Find the subplan\n        const subplanner = (\n          command.call.args.find(\n            (arg) => arg instanceof SubplanValue\n          ) as SubplanValue\n        ).planner;\n        // Build a list of commands\n        const subcommands = subplanner.buildCommands(ps);\n        // Encode them and push them to a new state slot\n        ps.state.push(\n          hexDataSlice(defaultAbiCoder.encode(['bytes32[]'], [subcommands]), 32)\n        );\n        // The slot is no longer needed after this command\n        ps.freeSlots.push(ps.state.length - 1);\n      }\n\n      let flags = command.call.flags;\n\n      const args = this.buildCommandArgs(\n        command,\n        ps.returnSlotMap,\n        ps.literalSlotMap,\n        ps.state\n      );\n\n      if (args.length > 6) {\n        flags |= CommandFlags.EXTENDED_COMMAND;\n      }\n\n      // Add any newly unused state slots to the list\n      ps.freeSlots = ps.freeSlots.concat(\n        ps.stateExpirations.get(command) || []\n      );\n\n      // Figure out where to put the return value\n      let ret = 0xff;\n      if (ps.commandVisibility.has(command)) {\n        if (\n          command.type === CommandType.RAWCALL ||\n          command.type === CommandType.SUBPLAN\n        ) {\n          throw new Error(\n            `Return value of ${command.call.fragment.name} cannot be used to replace state and in another function`\n          );\n        }\n        ret = ps.state.length;\n\n        if (ps.freeSlots.length > 0) {\n          ret = ps.freeSlots.pop() as number;\n        }\n\n        // Store the slot mapping\n        ps.returnSlotMap.set(command, ret);\n\n        // Make the slot available when it's not needed\n        const expiryCommand = ps.commandVisibility.get(command) as Command;\n        ps.stateExpirations.set(\n          expiryCommand,\n          (ps.stateExpirations.get(expiryCommand) || []).concat([ret])\n        );\n\n        if (ret === ps.state.length) {\n          ps.state.push('0x');\n        }\n\n        if (\n          isDynamicType(command.call.fragment.outputs?.[0]) ||\n          (command.call.flags & CommandFlags.TUPLE_RETURN) !== 0\n        ) {\n          ret |= 0x80;\n        }\n      } else if (\n        command.type === CommandType.RAWCALL ||\n        command.type === CommandType.SUBPLAN\n      ) {\n        if (\n          command.call.fragment.outputs &&\n          command.call.fragment.outputs.length === 1\n        ) {\n          ret = 0xfe;\n        }\n      }\n\n      if (\n        (flags & CommandFlags.EXTENDED_COMMAND) ===\n        CommandFlags.EXTENDED_COMMAND\n      ) {\n        // Extended command\n        encodedCommands.push(\n          hexConcat([\n            command.call.contract.interface.getSighash(command.call.fragment),\n            [flags, 0, 0, 0, 0, 0, 0, ret],\n            command.call.contract.address,\n          ])\n        );\n        encodedCommands.push(hexConcat([padArray(args, 32, 0xff)]));\n      } else {\n        // Standard command\n        encodedCommands.push(\n          hexConcat([\n            command.call.contract.interface.getSighash(command.call.fragment),\n            [flags],\n            padArray(args, 6, 0xff),\n            [ret],\n            command.call.contract.address,\n          ])\n        );\n      }\n    }\n    return encodedCommands;\n  }\n\n  plan(): { commands: string[]; state: string[] } {\n    // Tracks the last time a literal is used in the program\n    const literalVisibility = new Map<string, Command>();\n    // Tracks the last time a command's output is used in the program\n    const commandVisibility = new Map<Command, Command>();\n\n    this.preplan(commandVisibility, literalVisibility);\n\n    // Maps from commands to the slots that expire on execution (if any)\n    const stateExpirations = new Map<Command, number[]>();\n\n    // Tracks the state slot each literal is stored in\n    const literalSlotMap = new Map<string, number>();\n\n    const state = new Array<string>();\n\n    // Prepopulate the state and state expirations with literals\n    literalVisibility.forEach((lastCommand, literal) => {\n      const slot = state.length;\n      state.push(literal);\n      literalSlotMap.set(literal, slot);\n      stateExpirations.set(\n        lastCommand,\n        (stateExpirations.get(lastCommand) || []).concat([slot])\n      );\n    });\n\n    const ps: PlannerState = {\n      returnSlotMap: new Map<Command, number>(),\n      literalSlotMap,\n      freeSlots: new Array<number>(),\n      stateExpirations,\n      commandVisibility,\n      state,\n    };\n\n    let encodedCommands = this.buildCommands(ps);\n\n    return { commands: encodedCommands, state };\n  }\n}\n"],"names":["CommandFlags","LiteralValue","param","value","ReturnValue","command","StateValue","ParamType","from","SubplanValue","planner","FunctionCall","contract","flags","fragment","args","callvalue","withValue","this","CALLTYPE_MASK","CALL","CALL_WITH_VALUE","Error","encodeArg","rawValue","TUPLE_RETURN","staticcall","STATICCALL","isDynamicType","includes","baseType","arg","undefined","isValue","type","Planner","hexDataSlice","defaultAbiCoder","encode","abiEncodeSingle","buildCall","length","inputs","name","encodedArgs","map","idx","commandflags","CommandType","Contract","address","contractInterface","getStatic","functions","uniqueNames","uniqueSignatures","Object","keys","forEach","signature","_this","JSON","stringify","push","defineReadOnly","signatures","e","createContract","createLibrary","DELEGATECALL","getInterface","Interface","isInterface","Command","call","padArray","a","len","concat","Array","fill","state","commands","add","fromString","outputs","addSubplan","hasSubplan","hasState","SUBPLAN","replaceState","RAWCALL","preplan","commandVisibility","literalVisibility","seen","planners","Set","has","inargs","set","subplanSeen","buildCommandArgs","returnSlotMap","literalSlotMap","slot","get","buildCommands","ps","encodedCommands","subcommands","find","freeSlots","EXTENDED_COMMAND","stateExpirations","ret","pop","expiryCommand","_command$call$fragmen","hexConcat","getSighash","plan","Map","lastCommand","literal"],"mappings":"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"}