{"version":3,"file":"weiroll.js.esm.js","sources":["../src/planner.ts"],"sourcesContent":["import { ContractInterface } from '@ethersproject/contracts';\nimport type { Contract as EthersContract } from '@ethersproject/contracts';\nimport { Interface, ParamType, defaultAbiCoder } from '@ethersproject/abi';\nimport type { FunctionFragment } from '@ethersproject/abi';\nimport { defineReadOnly, getStatic } from '@ethersproject/properties';\nimport { hexConcat, hexDataSlice } from '@ethersproject/bytes';\n\nexport interface Value {\n  readonly param: ParamType;\n}\n\nfunction isValue(arg: any): arg is Value {\n  return (arg as Value).param !== undefined;\n}\n\nclass LiteralValue implements Value {\n  readonly param: ParamType;\n  readonly value: string;\n\n  constructor(param: ParamType, value: string) {\n    this.param = param;\n    this.value = value;\n  }\n}\n\nclass ReturnValue implements Value {\n  readonly param: ParamType;\n  readonly command: Command; // Function call we want the return value of\n\n  constructor(param: ParamType, command: Command) {\n    this.param = param;\n    this.command = command;\n  }\n}\n\nclass StateValue implements Value {\n  readonly param: ParamType;\n\n  constructor() {\n    this.param = ParamType.from('bytes[]');\n  }\n}\n\nclass SubplanValue implements Value {\n  readonly param: ParamType;\n  readonly planner: Planner;\n\n  constructor(planner: Planner) {\n    this.param = ParamType.from('bytes[]');\n    this.planner = planner;\n  }\n}\n\nexport enum CommandFlags {\n  DELEGATECALL = 0x00,\n  CALL = 0x01,\n  STATICCALL = 0x02,\n  CALL_WITH_VALUE = 0x03,\n  CALLTYPE_MASK = 0x03,\n  EXTENDED_COMMAND = 0x40,\n  TUPLE_RETURN = 0x80,\n}\n\nexport class FunctionCall {\n  readonly contract: Contract;\n  readonly flags: CommandFlags;\n  readonly fragment: FunctionFragment;\n  readonly args: Value[];\n  readonly callvalue?: Value;\n\n  constructor(\n    contract: Contract,\n    flags: CommandFlags,\n    fragment: FunctionFragment,\n    args: Value[],\n    callvalue?: Value\n  ) {\n    this.contract = contract;\n    this.flags = flags;\n    this.fragment = fragment;\n    this.args = args;\n    this.callvalue = callvalue;\n  }\n\n  withValue(value: Value): FunctionCall {\n    if (\n      (this.flags & CommandFlags.CALLTYPE_MASK) !== CommandFlags.CALL &&\n      (this.flags & CommandFlags.CALLTYPE_MASK) !== CommandFlags.CALL_WITH_VALUE\n    ) {\n      throw new Error('Only CALL operations can send value');\n    }\n    return new FunctionCall(\n      this.contract,\n      (this.flags & ~CommandFlags.CALLTYPE_MASK) | CommandFlags.CALL_WITH_VALUE,\n      this.fragment,\n      this.args,\n      encodeArg(value, ParamType.from('uint'))\n    );\n  }\n\n  rawValue(): FunctionCall {\n    return new FunctionCall(\n      this.contract,\n      this.flags | CommandFlags.TUPLE_RETURN,\n      this.fragment,\n      this.args,\n      this.callvalue\n    );\n  }\n\n  staticcall(): FunctionCall {\n    if ((this.flags & CommandFlags.CALLTYPE_MASK) !== CommandFlags.CALL) {\n      throw new Error('Only CALL operations can be made static');\n    }\n    return new FunctionCall(\n      this.contract,\n      (this.flags & ~CommandFlags.CALLTYPE_MASK) | CommandFlags.STATICCALL,\n      this.fragment,\n      this.args,\n      this.callvalue\n    );\n  }\n}\n\nexport type ContractFunction = (...args: Array<any>) => FunctionCall;\n\nexport function isDynamicType(param?: ParamType): boolean {\n  if (typeof param === 'undefined') return false;\n\n  return ['string', 'bytes', 'array', 'tuple'].includes(param.baseType);\n}\n\nfunction abiEncodeSingle(param: ParamType, value: any): LiteralValue {\n  if (isDynamicType(param)) {\n    return new LiteralValue(\n      param,\n      hexDataSlice(defaultAbiCoder.encode([param], [value]), 32)\n    );\n  }\n  return new LiteralValue(param, defaultAbiCoder.encode([param], [value]));\n}\n\nfunction encodeArg(arg: any, param: ParamType): Value {\n  if (isValue(arg)) {\n    if (arg.param.type !== param.type) {\n      // Todo: type casting rules\n      throw new Error(\n        `Cannot pass value of type ${arg.param.type} to input of type ${param.type}`\n      );\n    }\n    return arg;\n  } else if (arg instanceof Planner) {\n    return new SubplanValue(arg);\n  } else {\n    return abiEncodeSingle(param, arg);\n  }\n}\n\nfunction buildCall(\n  contract: Contract,\n  fragment: FunctionFragment\n): ContractFunction {\n  return function call(...args: Array<any>): FunctionCall {\n    if (args.length !== fragment.inputs.length) {\n      throw new Error(\n        `Function ${fragment.name} has ${fragment.inputs.length} arguments but ${args.length} provided`\n      );\n    }\n\n    const encodedArgs = args.map((arg, idx) =>\n      encodeArg(arg, fragment.inputs[idx])\n    );\n\n    return new FunctionCall(\n      contract,\n      contract.commandflags,\n      fragment,\n      encodedArgs\n    );\n  };\n}\n\nclass BaseContract {\n  readonly address: string;\n  readonly commandflags: CommandFlags;\n  readonly interface: Interface;\n  readonly functions: { [name: string]: ContractFunction };\n\n  constructor(\n    address: string,\n    contractInterface: ContractInterface,\n    commandflags: CommandFlags\n  ) {\n    this.interface = getStatic<\n      (contractInterface: ContractInterface) => Interface\n    >(\n      new.target,\n      'getInterface'\n    )(contractInterface);\n    if ((commandflags & ~CommandFlags.CALLTYPE_MASK) !== 0) {\n      throw new Error(\n        'Only calltype flags may be supplied to BaseContract constructor'\n      );\n    }\n\n    this.address = address;\n    this.commandflags = commandflags;\n    this.functions = {};\n\n    const uniqueNames: { [name: string]: Array<string> } = {};\n    const uniqueSignatures: { [signature: string]: boolean } = {};\n    Object.keys(this.interface.functions).forEach((signature) => {\n      const fragment = this.interface.functions[signature];\n\n      // Check that the signature is unique; if not the ABI generation has\n      // not been cleaned or may be incorrectly generated\n      if (uniqueSignatures[signature]) {\n        throw new Error(`Duplicate ABI entry for ${JSON.stringify(signature)}`);\n      }\n      uniqueSignatures[signature] = true;\n\n      // Track unique names; we only expose bare named functions if they\n      // are ambiguous\n      {\n        const name = fragment.name;\n        if (!uniqueNames[name]) {\n          uniqueNames[name] = [];\n        }\n        uniqueNames[name].push(signature);\n      }\n\n      if ((this as Contract)[signature] == null) {\n        defineReadOnly<any, any>(this, signature, buildCall(this, fragment));\n      }\n\n      // We do not collapse simple calls on this bucket, which allows\n      // frameworks to safely use this without introspection as well as\n      // allows decoding error recovery.\n      if (this.functions[signature] == null) {\n        defineReadOnly(this.functions, signature, buildCall(this, fragment));\n      }\n    });\n\n    Object.keys(uniqueNames).forEach((name) => {\n      // Ambiguous names to not get attached as bare names\n      const signatures = uniqueNames[name];\n      if (signatures.length > 1) {\n        return;\n      }\n\n      const signature = signatures[0];\n\n      // If overwriting a member property that is null, swallow the error\n      try {\n        if ((this as Contract)[name] == null) {\n          defineReadOnly(this as Contract, name, (this as Contract)[signature]);\n        }\n      } catch (e) {}\n\n      if (this.functions[name] == null) {\n        defineReadOnly(this.functions, name, this.functions[signature]);\n      }\n    });\n  }\n\n  static createContract(\n    contract: EthersContract,\n    commandflags = CommandFlags.CALL\n  ): Contract {\n    return new Contract(contract.address, contract.interface, commandflags);\n  }\n\n  static createLibrary(contract: EthersContract): Contract {\n    return new Contract(\n      contract.address,\n      contract.interface,\n      CommandFlags.DELEGATECALL\n    );\n  }\n\n  static getInterface(contractInterface: ContractInterface): Interface {\n    if (Interface.isInterface(contractInterface)) {\n      return contractInterface;\n    }\n    return new Interface(contractInterface);\n  }\n}\n\nexport class Contract extends BaseContract {\n  // The meta-class properties\n  readonly [key: string]: ContractFunction | any;\n}\n\nenum CommandType {\n  CALL,\n  RAWCALL,\n  SUBPLAN,\n}\n\nclass Command {\n  readonly call: FunctionCall;\n  readonly type: CommandType;\n\n  constructor(call: FunctionCall, type: CommandType) {\n    this.call = call;\n    this.type = type;\n  }\n}\n\ninterface PlannerState {\n  // Maps from a command to the slot used for its return value\n  returnSlotMap: Map<Command, number>;\n  // Maps from a literal to the slot used to store it\n  literalSlotMap: Map<string, number>;\n  // An array of unused state slots\n  freeSlots: Array<number>;\n  // Maps from a command to the slots that expire when it's executed\n  stateExpirations: Map<Command, number[]>;\n  // Maps from a command to the last command that consumes its output\n  commandVisibility: Map<Command, Command>;\n  // The initial state array\n  state: Array<string>;\n}\n\nfunction padArray(a: Array<number>, len: number, value: number): Array<number> {\n  return a.concat(new Array<number>(len - a.length).fill(value));\n}\n\nexport class Planner {\n  readonly state: StateValue;\n  commands: Command[];\n\n  constructor() {\n    this.state = new StateValue();\n    this.commands = [];\n  }\n\n  add(call: FunctionCall): ReturnValue | null {\n    const command = new Command(call, CommandType.CALL);\n    this.commands.push(command);\n\n    for (const arg of call.args) {\n      if (arg instanceof SubplanValue) {\n        throw new Error(\n          'Only subplans can have arguments of type SubplanValue'\n        );\n      }\n    }\n\n    if (call.flags & CommandFlags.TUPLE_RETURN) {\n      return new ReturnValue(ParamType.fromString('bytes'), command);\n    }\n    if (call.fragment.outputs?.length !== 1) {\n      return null;\n    }\n    return new ReturnValue(call.fragment.outputs[0], command);\n  }\n\n  addSubplan(call: FunctionCall) {\n    let hasSubplan = false;\n    let hasState = false;\n    for (const arg of call.args) {\n      if (arg instanceof SubplanValue) {\n        if (hasSubplan) {\n          throw new Error('Subplans can only take one planner argument');\n        }\n        hasSubplan = true;\n      }\n      if (arg instanceof StateValue) {\n        if (hasState) {\n          throw new Error('Subplans can only take one state argument');\n        }\n        hasState = true;\n      }\n    }\n    if (!hasSubplan || !hasState) {\n      throw new Error('Subplans must take planner and state arguments');\n    }\n    if (!hasSubplan || !hasState) {\n      throw new Error('Subplans must take planner and state arguments');\n    }\n\n    if (\n      call.fragment.outputs?.length === 1 &&\n      call.fragment.outputs[0].type !== 'bytes[]'\n    ) {\n      throw new Error(\n        'Subplans must return a bytes[] replacement state or nothing'\n      );\n    }\n\n    this.commands.push(new Command(call, CommandType.SUBPLAN));\n  }\n\n  replaceState(call: FunctionCall) {\n    if (\n      call.fragment.outputs?.length !== 1 ||\n      call.fragment.outputs[0].type !== 'bytes[]'\n    ) {\n      throw new Error('Function replacing state must return a bytes[]');\n    }\n\n    this.commands.push(new Command(call, CommandType.RAWCALL));\n  }\n\n  private preplan(\n    commandVisibility: Map<Command, Command>,\n    literalVisibility: Map<string, Command>,\n    seen?: Set<Command>,\n    planners?: Set<Planner>\n  ) {\n    if (seen === undefined) {\n      seen = new Set<Command>();\n    }\n    if (planners === undefined) {\n      planners = new Set<Planner>();\n    }\n\n    if (planners.has(this)) {\n      throw new Error('A planner cannot contain itself');\n    }\n    planners.add(this);\n\n    // Build visibility maps\n    for (let command of this.commands) {\n      let inargs = command.call.args;\n      if (\n        (command.call.flags & CommandFlags.CALLTYPE_MASK) ===\n        CommandFlags.CALL_WITH_VALUE\n      ) {\n        if (!command.call.callvalue) {\n          throw new Error('Call with value must have a value parameter');\n        }\n        inargs = [command.call.callvalue].concat(inargs);\n      }\n\n      for (let arg of inargs) {\n        if (arg instanceof ReturnValue) {\n          if (!seen.has(arg.command)) {\n            throw new Error(\n              `Return value from \"${arg.command.call.fragment.name}\" is not visible here`\n            );\n          }\n          commandVisibility.set(arg.command, command);\n        } else if (arg instanceof LiteralValue) {\n          literalVisibility.set(arg.value, command);\n        } else if (arg instanceof SubplanValue) {\n          let subplanSeen = seen;\n          if (\n            !command.call.fragment.outputs ||\n            command.call.fragment.outputs.length === 0\n          ) {\n            // Read-only subplan; return values aren't visible externally\n            subplanSeen = new Set<Command>(seen);\n          }\n          arg.planner.preplan(\n            commandVisibility,\n            literalVisibility,\n            subplanSeen,\n            planners\n          );\n        } else if (!(arg instanceof StateValue)) {\n          throw new Error(`Unknown function argument type '${typeof arg}'`);\n        }\n      }\n      seen.add(command);\n    }\n\n    return { commandVisibility, literalVisibility };\n  }\n\n  private buildCommandArgs(\n    command: Command,\n    returnSlotMap: Map<Command, number>,\n    literalSlotMap: Map<string, number>,\n    state: Array<string>\n  ): Array<number> {\n    // Build a list of argument value indexes\n    let inargs = command.call.args;\n    if (\n      (command.call.flags & CommandFlags.CALLTYPE_MASK) ===\n      CommandFlags.CALL_WITH_VALUE\n    ) {\n      if (!command.call.callvalue) {\n        throw new Error('Call with value must have a value parameter');\n      }\n      inargs = [command.call.callvalue].concat(inargs);\n    }\n\n    const args = new Array<number>();\n    inargs.forEach((arg) => {\n      let slot: number;\n      if (arg instanceof ReturnValue) {\n        slot = returnSlotMap.get(arg.command) as number;\n      } else if (arg instanceof LiteralValue) {\n        slot = literalSlotMap.get(arg.value) as number;\n      } else if (arg instanceof StateValue) {\n        slot = 0xfe;\n      } else if (arg instanceof SubplanValue) {\n        // buildCommands has already built the subplan and put it in the last state slot\n        slot = state.length - 1;\n      } else {\n        throw new Error(`Unknown function argument type '${typeof arg}'`);\n      }\n      if (isDynamicType(arg.param)) {\n        slot |= 0x80;\n      }\n      args.push(slot);\n    });\n\n    return args;\n  }\n\n  private buildCommands(ps: PlannerState): Array<string> {\n    const encodedCommands = new Array<string>();\n    // Build commands, and add state entries as needed\n    for (let command of this.commands) {\n      if (command.type === CommandType.SUBPLAN) {\n        // Find the subplan\n        const subplanner = (\n          command.call.args.find(\n            (arg) => arg instanceof SubplanValue\n          ) as SubplanValue\n        ).planner;\n        // Build a list of commands\n        const subcommands = subplanner.buildCommands(ps);\n        // Encode them and push them to a new state slot\n        ps.state.push(\n          hexDataSlice(defaultAbiCoder.encode(['bytes32[]'], [subcommands]), 32)\n        );\n        // The slot is no longer needed after this command\n        ps.freeSlots.push(ps.state.length - 1);\n      }\n\n      let flags = command.call.flags;\n\n      const args = this.buildCommandArgs(\n        command,\n        ps.returnSlotMap,\n        ps.literalSlotMap,\n        ps.state\n      );\n\n      if (args.length > 6) {\n        flags |= CommandFlags.EXTENDED_COMMAND;\n      }\n\n      // Add any newly unused state slots to the list\n      ps.freeSlots = ps.freeSlots.concat(\n        ps.stateExpirations.get(command) || []\n      );\n\n      // Figure out where to put the return value\n      let ret = 0xff;\n      if (ps.commandVisibility.has(command)) {\n        if (\n          command.type === CommandType.RAWCALL ||\n          command.type === CommandType.SUBPLAN\n        ) {\n          throw new Error(\n            `Return value of ${command.call.fragment.name} cannot be used to replace state and in another function`\n          );\n        }\n        ret = ps.state.length;\n\n        if (ps.freeSlots.length > 0) {\n          ret = ps.freeSlots.pop() as number;\n        }\n\n        // Store the slot mapping\n        ps.returnSlotMap.set(command, ret);\n\n        // Make the slot available when it's not needed\n        const expiryCommand = ps.commandVisibility.get(command) as Command;\n        ps.stateExpirations.set(\n          expiryCommand,\n          (ps.stateExpirations.get(expiryCommand) || []).concat([ret])\n        );\n\n        if (ret === ps.state.length) {\n          ps.state.push('0x');\n        }\n\n        if (\n          isDynamicType(command.call.fragment.outputs?.[0]) ||\n          (command.call.flags & CommandFlags.TUPLE_RETURN) !== 0\n        ) {\n          ret |= 0x80;\n        }\n      } else if (\n        command.type === CommandType.RAWCALL ||\n        command.type === CommandType.SUBPLAN\n      ) {\n        if (\n          command.call.fragment.outputs &&\n          command.call.fragment.outputs.length === 1\n        ) {\n          ret = 0xfe;\n        }\n      }\n\n      if (\n        (flags & CommandFlags.EXTENDED_COMMAND) ===\n        CommandFlags.EXTENDED_COMMAND\n      ) {\n        // Extended command\n        encodedCommands.push(\n          hexConcat([\n            command.call.contract.interface.getSighash(command.call.fragment),\n            [flags, 0, 0, 0, 0, 0, 0, ret],\n            command.call.contract.address,\n          ])\n        );\n        encodedCommands.push(hexConcat([padArray(args, 32, 0xff)]));\n      } else {\n        // Standard command\n        encodedCommands.push(\n          hexConcat([\n            command.call.contract.interface.getSighash(command.call.fragment),\n            [flags],\n            padArray(args, 6, 0xff),\n            [ret],\n            command.call.contract.address,\n          ])\n        );\n      }\n    }\n    return encodedCommands;\n  }\n\n  plan(): { commands: string[]; state: string[] } {\n    // Tracks the last time a literal is used in the program\n    const literalVisibility = new Map<string, Command>();\n    // Tracks the last time a command's output is used in the program\n    const commandVisibility = new Map<Command, Command>();\n\n    this.preplan(commandVisibility, literalVisibility);\n\n    // Maps from commands to the slots that expire on execution (if any)\n    const stateExpirations = new Map<Command, number[]>();\n\n    // Tracks the state slot each literal is stored in\n    const literalSlotMap = new Map<string, number>();\n\n    const state = new Array<string>();\n\n    // Prepopulate the state and state expirations with literals\n    literalVisibility.forEach((lastCommand, literal) => {\n      const slot = state.length;\n      state.push(literal);\n      literalSlotMap.set(literal, slot);\n      stateExpirations.set(\n        lastCommand,\n        (stateExpirations.get(lastCommand) || []).concat([slot])\n      );\n    });\n\n    const ps: PlannerState = {\n      returnSlotMap: new Map<Command, number>(),\n      literalSlotMap,\n      freeSlots: new Array<number>(),\n      stateExpirations,\n      commandVisibility,\n      state,\n    };\n\n    let encodedCommands = this.buildCommands(ps);\n\n    return { commands: encodedCommands, state };\n  }\n}\n"],"names":["isValue","arg","param","undefined","LiteralValue","value","ReturnValue","command","StateValue","ParamType","from","SubplanValue","planner","CommandFlags","FunctionCall","contract","flags","fragment","args","callvalue","withValue","CALLTYPE_MASK","CALL","CALL_WITH_VALUE","Error","encodeArg","rawValue","TUPLE_RETURN","staticcall","STATICCALL","isDynamicType","includes","baseType","abiEncodeSingle","hexDataSlice","defaultAbiCoder","encode","type","Planner","buildCall","call","length","inputs","name","encodedArgs","map","idx","commandflags","BaseContract","address","contractInterface","getStatic","functions","uniqueNames","uniqueSignatures","Object","keys","forEach","signature","JSON","stringify","push","defineReadOnly","signatures","e","createContract","Contract","createLibrary","DELEGATECALL","getInterface","Interface","isInterface","CommandType","Command","padArray","a","len","concat","Array","fill","state","commands","add","fromString","outputs","addSubplan","hasSubplan","hasState","SUBPLAN","replaceState","RAWCALL","preplan","commandVisibility","literalVisibility","seen","planners","Set","has","inargs","set","subplanSeen","buildCommandArgs","returnSlotMap","literalSlotMap","slot","get","buildCommands","ps","encodedCommands","subplanner","find","subcommands","freeSlots","EXTENDED_COMMAND","stateExpirations","ret","pop","expiryCommand","hexConcat","getSighash","plan","Map","lastCommand","literal"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA,SAASA,OAAT,CAAiBC,GAAjB;AACE,SAAQA,GAAa,CAACC,KAAd,KAAwBC,SAAhC;AACD;;IAEKC,eAIJ,sBAAYF,KAAZ,EAA8BG,KAA9B;AACE,OAAKH,KAAL,GAAaA,KAAb;AACA,OAAKG,KAAL,GAAaA,KAAb;AACD;;IAGGC,cAIJ,qBAAYJ,KAAZ,EAA8BK,OAA9B;AACE,OAAKL,KAAL,GAAaA,KAAb;AACA,OAAKK,OAAL,GAAeA,OAAf;AACD;;IAGGC,aAGJ;AACE,OAAKN,KAAL,GAAaO,SAAS,CAACC,IAAV,CAAe,SAAf,CAAb;AACD;;IAGGC,eAIJ,sBAAYC,OAAZ;AACE,OAAKV,KAAL,GAAaO,SAAS,CAACC,IAAV,CAAe,SAAf,CAAb;AACA,OAAKE,OAAL,GAAeA,OAAf;AACD;;AAGH,IAAYC,YAAZ;;AAAA,WAAYA;AACVA,EAAAA,8CAAA,iBAAA;AACAA,EAAAA,sCAAA,SAAA;AACAA,EAAAA,4CAAA,eAAA;AACAA,EAAAA,iDAAA,oBAAA;AACAA,EAAAA,+CAAA,kBAAA;AACAA,EAAAA,mDAAA,qBAAA;AACAA,EAAAA,gDAAA,iBAAA;AACD,CARD,EAAYA,YAAY,KAAZA,YAAY,KAAA,CAAxB;;IAUaC,YAAb;AAOE,wBACEC,QADF,EAEEC,KAFF,EAGEC,QAHF,EAIEC,IAJF,EAKEC,SALF;AAOE,SAAKJ,QAAL,GAAgBA,QAAhB;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACD;;AAnBH;;AAAA,SAqBEC,SArBF,GAqBE,mBAAUf,KAAV;AACE,QACE,CAAC,KAAKW,KAAL,GAAaH,YAAY,CAACQ,aAA3B,MAA8CR,YAAY,CAACS,IAA3D,IACA,CAAC,KAAKN,KAAL,GAAaH,YAAY,CAACQ,aAA3B,MAA8CR,YAAY,CAACU,eAF7D,EAGE;AACA,YAAM,IAAIC,KAAJ,CAAU,qCAAV,CAAN;AACD;;AACD,WAAO,IAAIV,YAAJ,CACL,KAAKC,QADA,EAEJ,KAAKC,KAAL,GAAa,CAACH,YAAY,CAACQ,aAA5B,GAA6CR,YAAY,CAACU,eAFrD,EAGL,KAAKN,QAHA,EAIL,KAAKC,IAJA,EAKLO,SAAS,CAACpB,KAAD,EAAQI,SAAS,CAACC,IAAV,CAAe,MAAf,CAAR,CALJ,CAAP;AAOD,GAnCH;;AAAA,SAqCEgB,QArCF,GAqCE;AACE,WAAO,IAAIZ,YAAJ,CACL,KAAKC,QADA,EAEL,KAAKC,KAAL,GAAaH,YAAY,CAACc,YAFrB,EAGL,KAAKV,QAHA,EAIL,KAAKC,IAJA,EAKL,KAAKC,SALA,CAAP;AAOD,GA7CH;;AAAA,SA+CES,UA/CF,GA+CE;AACE,QAAI,CAAC,KAAKZ,KAAL,GAAaH,YAAY,CAACQ,aAA3B,MAA8CR,YAAY,CAACS,IAA/D,EAAqE;AACnE,YAAM,IAAIE,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,WAAO,IAAIV,YAAJ,CACL,KAAKC,QADA,EAEJ,KAAKC,KAAL,GAAa,CAACH,YAAY,CAACQ,aAA5B,GAA6CR,YAAY,CAACgB,UAFrD,EAGL,KAAKZ,QAHA,EAIL,KAAKC,IAJA,EAKL,KAAKC,SALA,CAAP;AAOD,GA1DH;;AAAA;AAAA;SA+DgBW,cAAc5B;AAC5B,MAAI,OAAOA,KAAP,KAAiB,WAArB,EAAkC,OAAO,KAAP;AAElC,SAAO,CAAC,QAAD,EAAW,OAAX,EAAoB,OAApB,EAA6B,OAA7B,EAAsC6B,QAAtC,CAA+C7B,KAAK,CAAC8B,QAArD,CAAP;AACD;;AAED,SAASC,eAAT,CAAyB/B,KAAzB,EAA2CG,KAA3C;AACE,MAAIyB,aAAa,CAAC5B,KAAD,CAAjB,EAA0B;AACxB,WAAO,IAAIE,YAAJ,CACLF,KADK,EAELgC,YAAY,CAACC,eAAe,CAACC,MAAhB,CAAuB,CAAClC,KAAD,CAAvB,EAAgC,CAACG,KAAD,CAAhC,CAAD,EAA2C,EAA3C,CAFP,CAAP;AAID;;AACD,SAAO,IAAID,YAAJ,CAAiBF,KAAjB,EAAwBiC,eAAe,CAACC,MAAhB,CAAuB,CAAClC,KAAD,CAAvB,EAAgC,CAACG,KAAD,CAAhC,CAAxB,CAAP;AACD;;AAED,SAASoB,SAAT,CAAmBxB,GAAnB,EAA6BC,KAA7B;AACE,MAAIF,OAAO,CAACC,GAAD,CAAX,EAAkB;AAChB,QAAIA,GAAG,CAACC,KAAJ,CAAUmC,IAAV,KAAmBnC,KAAK,CAACmC,IAA7B,EAAmC;AACjC;AACA,YAAM,IAAIb,KAAJ,gCACyBvB,GAAG,CAACC,KAAJ,CAAUmC,IADnC,0BAC4DnC,KAAK,CAACmC,IADlE,CAAN;AAGD;;AACD,WAAOpC,GAAP;AACD,GARD,MAQO,IAAIA,GAAG,YAAYqC,OAAnB,EAA4B;AACjC,WAAO,IAAI3B,YAAJ,CAAiBV,GAAjB,CAAP;AACD,GAFM,MAEA;AACL,WAAOgC,eAAe,CAAC/B,KAAD,EAAQD,GAAR,CAAtB;AACD;AACF;;AAED,SAASsC,SAAT,CACExB,QADF,EAEEE,QAFF;AAIE,SAAO,SAASuB,IAAT;sCAAiBtB;AAAAA,MAAAA;;;AACtB,QAAIA,IAAI,CAACuB,MAAL,KAAgBxB,QAAQ,CAACyB,MAAT,CAAgBD,MAApC,EAA4C;AAC1C,YAAM,IAAIjB,KAAJ,eACQP,QAAQ,CAAC0B,IADjB,aAC6B1B,QAAQ,CAACyB,MAAT,CAAgBD,MAD7C,uBACqEvB,IAAI,CAACuB,MAD1E,eAAN;AAGD;;AAED,QAAMG,WAAW,GAAG1B,IAAI,CAAC2B,GAAL,CAAS,UAAC5C,GAAD,EAAM6C,GAAN;AAAA,aAC3BrB,SAAS,CAACxB,GAAD,EAAMgB,QAAQ,CAACyB,MAAT,CAAgBI,GAAhB,CAAN,CADkB;AAAA,KAAT,CAApB;AAIA,WAAO,IAAIhC,YAAJ,CACLC,QADK,EAELA,QAAQ,CAACgC,YAFJ,EAGL9B,QAHK,EAIL2B,WAJK,CAAP;AAMD,GAjBD;AAkBD;;IAEKI;AAMJ,wBACEC,OADF,EAEEC,iBAFF,EAGEH,YAHF;;;AAKE,wBAAiBI,SAAS,2DAIxB,cAJwB,CAAT,CAKfD,iBALe,CAAjB;;AAMA,QAAI,CAACH,YAAY,GAAG,CAAClC,YAAY,CAACQ,aAA9B,MAAiD,CAArD,EAAwD;AACtD,YAAM,IAAIG,KAAJ,CACJ,iEADI,CAAN;AAGD;;AAED,SAAKyB,OAAL,GAAeA,OAAf;AACA,SAAKF,YAAL,GAAoBA,YAApB;AACA,SAAKK,SAAL,GAAiB,EAAjB;AAEA,QAAMC,WAAW,GAAsC,EAAvD;AACA,QAAMC,gBAAgB,GAAqC,EAA3D;AACAC,IAAAA,MAAM,CAACC,IAAP,CAAY,kBAAeJ,SAA3B,EAAsCK,OAAtC,CAA8C,UAACC,SAAD;AAC5C,UAAMzC,QAAQ,GAAG,KAAI,aAAJ,CAAemC,SAAf,CAAyBM,SAAzB,CAAjB;AAGA;;AACA,UAAIJ,gBAAgB,CAACI,SAAD,CAApB,EAAiC;AAC/B,cAAM,IAAIlC,KAAJ,8BAAqCmC,IAAI,CAACC,SAAL,CAAeF,SAAf,CAArC,CAAN;AACD;;AACDJ,MAAAA,gBAAgB,CAACI,SAAD,CAAhB,GAA8B,IAA9B;AAGA;;AACA;AACE,YAAMf,IAAI,GAAG1B,QAAQ,CAAC0B,IAAtB;;AACA,YAAI,CAACU,WAAW,CAACV,IAAD,CAAhB,EAAwB;AACtBU,UAAAA,WAAW,CAACV,IAAD,CAAX,GAAoB,EAApB;AACD;;AACDU,QAAAA,WAAW,CAACV,IAAD,CAAX,CAAkBkB,IAAlB,CAAuBH,SAAvB;AACD;;AAED,UAAK,KAAiB,CAACA,SAAD,CAAjB,IAAgC,IAArC,EAA2C;AACzCI,QAAAA,cAAc,CAAW,KAAX,EAAiBJ,SAAjB,EAA4BnB,SAAS,CAAC,KAAD,EAAOtB,QAAP,CAArC,CAAd;AACD;AAGD;AACA;;;AACA,UAAI,KAAI,CAACmC,SAAL,CAAeM,SAAf,KAA6B,IAAjC,EAAuC;AACrCI,QAAAA,cAAc,CAAC,KAAI,CAACV,SAAN,EAAiBM,SAAjB,EAA4BnB,SAAS,CAAC,KAAD,EAAOtB,QAAP,CAArC,CAAd;AACD;AACF,KA9BD;AAgCAsC,IAAAA,MAAM,CAACC,IAAP,CAAYH,WAAZ,EAAyBI,OAAzB,CAAiC,UAACd,IAAD;AAC/B;AACA,UAAMoB,UAAU,GAAGV,WAAW,CAACV,IAAD,CAA9B;;AACA,UAAIoB,UAAU,CAACtB,MAAX,GAAoB,CAAxB,EAA2B;AACzB;AACD;;AAED,UAAMiB,SAAS,GAAGK,UAAU,CAAC,CAAD,CAA5B;;AAGA,UAAI;AACF,YAAK,KAAiB,CAACpB,IAAD,CAAjB,IAA2B,IAAhC,EAAsC;AACpCmB,UAAAA,cAAc,CAAC,KAAD,EAAmBnB,IAAnB,EAA0B,KAAiB,CAACe,SAAD,CAA3C,CAAd;AACD;AACF,OAJD,CAIE,OAAOM,CAAP,EAAU;;AAEZ,UAAI,KAAI,CAACZ,SAAL,CAAeT,IAAf,KAAwB,IAA5B,EAAkC;AAChCmB,QAAAA,cAAc,CAAC,KAAI,CAACV,SAAN,EAAiBT,IAAjB,EAAuB,KAAI,CAACS,SAAL,CAAeM,SAAf,CAAvB,CAAd;AACD;AACF,KAnBD;AAoBD;;eAEMO,iBAAP,wBACElD,QADF,EAEEgC,YAFF;QAEEA;AAAAA,MAAAA,eAAelC,YAAY,CAACS;;;AAE5B,WAAO,IAAI4C,QAAJ,CAAanD,QAAQ,CAACkC,OAAtB,EAA+BlC,QAAQ,aAAvC,EAAmDgC,YAAnD,CAAP;AACD;;eAEMoB,gBAAP,uBAAqBpD,QAArB;AACE,WAAO,IAAImD,QAAJ,CACLnD,QAAQ,CAACkC,OADJ,EAELlC,QAAQ,aAFH,EAGLF,YAAY,CAACuD,YAHR,CAAP;AAKD;;eAEMC,eAAP,sBAAoBnB,iBAApB;AACE,QAAIoB,SAAS,CAACC,WAAV,CAAsBrB,iBAAtB,CAAJ,EAA8C;AAC5C,aAAOA,iBAAP;AACD;;AACD,WAAO,IAAIoB,SAAJ,CAAcpB,iBAAd,CAAP;AACD;;;;;IAGUgB,QAAb;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,EAA8BlB,YAA9B;AAKA,IAAKwB,WAAL;;AAAA,WAAKA;AACHA,EAAAA,oCAAA,SAAA;AACAA,EAAAA,uCAAA,YAAA;AACAA,EAAAA,uCAAA,YAAA;AACD,CAJD,EAAKA,WAAW,KAAXA,WAAW,KAAA,CAAhB;;IAMMC,UAIJ,iBAAYjC,IAAZ,EAAgCH,IAAhC;AACE,OAAKG,IAAL,GAAYA,IAAZ;AACA,OAAKH,IAAL,GAAYA,IAAZ;AACD;;AAkBH,SAASqC,QAAT,CAAkBC,CAAlB,EAAoCC,GAApC,EAAiDvE,KAAjD;AACE,SAAOsE,CAAC,CAACE,MAAF,CAAS,IAAIC,KAAJ,CAAkBF,GAAG,GAAGD,CAAC,CAAClC,MAA1B,EAAkCsC,IAAlC,CAAuC1E,KAAvC,CAAT,CAAP;AACD;;IAEYiC,OAAb;AAIE;AACE,SAAK0C,KAAL,GAAa,IAAIxE,UAAJ,EAAb;AACA,SAAKyE,QAAL,GAAgB,EAAhB;AACD;;AAPH;;AAAA,UASEC,GATF,GASE,aAAI1C,IAAJ;;;AACE,QAAMjC,OAAO,GAAG,IAAIkE,OAAJ,CAAYjC,IAAZ,EAAkBgC,WAAW,CAAClD,IAA9B,CAAhB;AACA,SAAK2D,QAAL,CAAcpB,IAAd,CAAmBtD,OAAnB;;AAEA,yDAAkBiC,IAAI,CAACtB,IAAvB,wCAA6B;AAAA,UAAlBjB,GAAkB;;AAC3B,UAAIA,GAAG,YAAYU,YAAnB,EAAiC;AAC/B,cAAM,IAAIa,KAAJ,CACJ,uDADI,CAAN;AAGD;AACF;;AAED,QAAIgB,IAAI,CAACxB,KAAL,GAAaH,YAAY,CAACc,YAA9B,EAA4C;AAC1C,aAAO,IAAIrB,WAAJ,CAAgBG,SAAS,CAAC0E,UAAV,CAAqB,OAArB,CAAhB,EAA+C5E,OAA/C,CAAP;AACD;;AACD,QAAI,0BAAAiC,IAAI,CAACvB,QAAL,CAAcmE,OAAd,2CAAuB3C,MAAvB,MAAkC,CAAtC,EAAyC;AACvC,aAAO,IAAP;AACD;;AACD,WAAO,IAAInC,WAAJ,CAAgBkC,IAAI,CAACvB,QAAL,CAAcmE,OAAd,CAAsB,CAAtB,CAAhB,EAA0C7E,OAA1C,CAAP;AACD,GA5BH;;AAAA,UA8BE8E,UA9BF,GA8BE,oBAAW7C,IAAX;;;AACE,QAAI8C,UAAU,GAAG,KAAjB;AACA,QAAIC,QAAQ,GAAG,KAAf;;AACA,0DAAkB/C,IAAI,CAACtB,IAAvB,2CAA6B;AAAA,UAAlBjB,GAAkB;;AAC3B,UAAIA,GAAG,YAAYU,YAAnB,EAAiC;AAC/B,YAAI2E,UAAJ,EAAgB;AACd,gBAAM,IAAI9D,KAAJ,CAAU,6CAAV,CAAN;AACD;;AACD8D,QAAAA,UAAU,GAAG,IAAb;AACD;;AACD,UAAIrF,GAAG,YAAYO,UAAnB,EAA+B;AAC7B,YAAI+E,QAAJ,EAAc;AACZ,gBAAM,IAAI/D,KAAJ,CAAU,2CAAV,CAAN;AACD;;AACD+D,QAAAA,QAAQ,GAAG,IAAX;AACD;AACF;;AACD,QAAI,CAACD,UAAD,IAAe,CAACC,QAApB,EAA8B;AAC5B,YAAM,IAAI/D,KAAJ,CAAU,gDAAV,CAAN;AACD;;AACD,QAAI,CAAC8D,UAAD,IAAe,CAACC,QAApB,EAA8B;AAC5B,YAAM,IAAI/D,KAAJ,CAAU,gDAAV,CAAN;AACD;;AAED,QACE,2BAAAgB,IAAI,CAACvB,QAAL,CAAcmE,OAAd,4CAAuB3C,MAAvB,MAAkC,CAAlC,IACAD,IAAI,CAACvB,QAAL,CAAcmE,OAAd,CAAsB,CAAtB,EAAyB/C,IAAzB,KAAkC,SAFpC,EAGE;AACA,YAAM,IAAIb,KAAJ,CACJ,6DADI,CAAN;AAGD;;AAED,SAAKyD,QAAL,CAAcpB,IAAd,CAAmB,IAAIY,OAAJ,CAAYjC,IAAZ,EAAkBgC,WAAW,CAACgB,OAA9B,CAAnB;AACD,GAhEH;;AAAA,UAkEEC,YAlEF,GAkEE,sBAAajD,IAAb;;;AACE,QACE,2BAAAA,IAAI,CAACvB,QAAL,CAAcmE,OAAd,4CAAuB3C,MAAvB,MAAkC,CAAlC,IACAD,IAAI,CAACvB,QAAL,CAAcmE,OAAd,CAAsB,CAAtB,EAAyB/C,IAAzB,KAAkC,SAFpC,EAGE;AACA,YAAM,IAAIb,KAAJ,CAAU,gDAAV,CAAN;AACD;;AAED,SAAKyD,QAAL,CAAcpB,IAAd,CAAmB,IAAIY,OAAJ,CAAYjC,IAAZ,EAAkBgC,WAAW,CAACkB,OAA9B,CAAnB;AACD,GA3EH;;AAAA,UA6EUC,OA7EV,GA6EU,iBACNC,iBADM,EAENC,iBAFM,EAGNC,IAHM,EAINC,QAJM;AAMN,QAAID,IAAI,KAAK3F,SAAb,EAAwB;AACtB2F,MAAAA,IAAI,GAAG,IAAIE,GAAJ,EAAP;AACD;;AACD,QAAID,QAAQ,KAAK5F,SAAjB,EAA4B;AAC1B4F,MAAAA,QAAQ,GAAG,IAAIC,GAAJ,EAAX;AACD;;AAED,QAAID,QAAQ,CAACE,GAAT,CAAa,IAAb,CAAJ,EAAwB;AACtB,YAAM,IAAIzE,KAAJ,CAAU,iCAAV,CAAN;AACD;;AACDuE,IAAAA,QAAQ,CAACb,GAAT,CAAa,IAAb;;AAGA,0DAAoB,KAAKD,QAAzB,2CAAmC;AAAA,UAA1B1E,OAA0B;AACjC,UAAI2F,MAAM,GAAG3F,OAAO,CAACiC,IAAR,CAAatB,IAA1B;;AACA,UACE,CAACX,OAAO,CAACiC,IAAR,CAAaxB,KAAb,GAAqBH,YAAY,CAACQ,aAAnC,MACAR,YAAY,CAACU,eAFf,EAGE;AACA,YAAI,CAAChB,OAAO,CAACiC,IAAR,CAAarB,SAAlB,EAA6B;AAC3B,gBAAM,IAAIK,KAAJ,CAAU,6CAAV,CAAN;AACD;;AACD0E,QAAAA,MAAM,GAAG,CAAC3F,OAAO,CAACiC,IAAR,CAAarB,SAAd,EAAyB0D,MAAzB,CAAgCqB,MAAhC,CAAT;AACD;;AAED,4DAAgBA,MAAhB,2CAAwB;AAAA,YAAfjG,GAAe;;AACtB,YAAIA,GAAG,YAAYK,WAAnB,EAAgC;AAC9B,cAAI,CAACwF,IAAI,CAACG,GAAL,CAAShG,GAAG,CAACM,OAAb,CAAL,EAA4B;AAC1B,kBAAM,IAAIiB,KAAJ,0BACkBvB,GAAG,CAACM,OAAJ,CAAYiC,IAAZ,CAAiBvB,QAAjB,CAA0B0B,IAD5C,4BAAN;AAGD;;AACDiD,UAAAA,iBAAiB,CAACO,GAAlB,CAAsBlG,GAAG,CAACM,OAA1B,EAAmCA,OAAnC;AACD,SAPD,MAOO,IAAIN,GAAG,YAAYG,YAAnB,EAAiC;AACtCyF,UAAAA,iBAAiB,CAACM,GAAlB,CAAsBlG,GAAG,CAACI,KAA1B,EAAiCE,OAAjC;AACD,SAFM,MAEA,IAAIN,GAAG,YAAYU,YAAnB,EAAiC;AACtC,cAAIyF,WAAW,GAAGN,IAAlB;;AACA,cACE,CAACvF,OAAO,CAACiC,IAAR,CAAavB,QAAb,CAAsBmE,OAAvB,IACA7E,OAAO,CAACiC,IAAR,CAAavB,QAAb,CAAsBmE,OAAtB,CAA8B3C,MAA9B,KAAyC,CAF3C,EAGE;AACA;AACA2D,YAAAA,WAAW,GAAG,IAAIJ,GAAJ,CAAiBF,IAAjB,CAAd;AACD;;AACD7F,UAAAA,GAAG,CAACW,OAAJ,CAAY+E,OAAZ,CACEC,iBADF,EAEEC,iBAFF,EAGEO,WAHF,EAIEL,QAJF;AAMD,SAfM,MAeA,IAAI,EAAE9F,GAAG,YAAYO,UAAjB,CAAJ,EAAkC;AACvC,gBAAM,IAAIgB,KAAJ,sCAA6C,OAAOvB,GAApD,OAAN;AACD;AACF;;AACD6F,MAAAA,IAAI,CAACZ,GAAL,CAAS3E,OAAT;AACD;;AAED,WAAO;AAAEqF,MAAAA,iBAAiB,EAAjBA,iBAAF;AAAqBC,MAAAA,iBAAiB,EAAjBA;AAArB,KAAP;AACD,GA7IH;;AAAA,UA+IUQ,gBA/IV,GA+IU,0BACN9F,OADM,EAEN+F,aAFM,EAGNC,cAHM,EAINvB,KAJM;AAMN;AACA,QAAIkB,MAAM,GAAG3F,OAAO,CAACiC,IAAR,CAAatB,IAA1B;;AACA,QACE,CAACX,OAAO,CAACiC,IAAR,CAAaxB,KAAb,GAAqBH,YAAY,CAACQ,aAAnC,MACAR,YAAY,CAACU,eAFf,EAGE;AACA,UAAI,CAAChB,OAAO,CAACiC,IAAR,CAAarB,SAAlB,EAA6B;AAC3B,cAAM,IAAIK,KAAJ,CAAU,6CAAV,CAAN;AACD;;AACD0E,MAAAA,MAAM,GAAG,CAAC3F,OAAO,CAACiC,IAAR,CAAarB,SAAd,EAAyB0D,MAAzB,CAAgCqB,MAAhC,CAAT;AACD;;AAED,QAAMhF,IAAI,GAAG,IAAI4D,KAAJ,EAAb;AACAoB,IAAAA,MAAM,CAACzC,OAAP,CAAe,UAACxD,GAAD;AACb,UAAIuG,IAAJ;;AACA,UAAIvG,GAAG,YAAYK,WAAnB,EAAgC;AAC9BkG,QAAAA,IAAI,GAAGF,aAAa,CAACG,GAAd,CAAkBxG,GAAG,CAACM,OAAtB,CAAP;AACD,OAFD,MAEO,IAAIN,GAAG,YAAYG,YAAnB,EAAiC;AACtCoG,QAAAA,IAAI,GAAGD,cAAc,CAACE,GAAf,CAAmBxG,GAAG,CAACI,KAAvB,CAAP;AACD,OAFM,MAEA,IAAIJ,GAAG,YAAYO,UAAnB,EAA+B;AACpCgG,QAAAA,IAAI,GAAG,IAAP;AACD,OAFM,MAEA,IAAIvG,GAAG,YAAYU,YAAnB,EAAiC;AACtC;AACA6F,QAAAA,IAAI,GAAGxB,KAAK,CAACvC,MAAN,GAAe,CAAtB;AACD,OAHM,MAGA;AACL,cAAM,IAAIjB,KAAJ,sCAA6C,OAAOvB,GAApD,OAAN;AACD;;AACD,UAAI6B,aAAa,CAAC7B,GAAG,CAACC,KAAL,CAAjB,EAA8B;AAC5BsG,QAAAA,IAAI,IAAI,IAAR;AACD;;AACDtF,MAAAA,IAAI,CAAC2C,IAAL,CAAU2C,IAAV;AACD,KAlBD;AAoBA,WAAOtF,IAAP;AACD,GAvLH;;AAAA,UAyLUwF,aAzLV,GAyLU,uBAAcC,EAAd;AACN,QAAMC,eAAe,GAAG,IAAI9B,KAAJ,EAAxB;;AAEA,0DAAoB,KAAKG,QAAzB,2CAAmC;AAAA,UAA1B1E,OAA0B;;AACjC,UAAIA,OAAO,CAAC8B,IAAR,KAAiBmC,WAAW,CAACgB,OAAjC,EAA0C;AACxC;AACA,YAAMqB,UAAU,GACdtG,OAAO,CAACiC,IAAR,CAAatB,IAAb,CAAkB4F,IAAlB,CACE,UAAC7G,GAAD;AAAA,iBAASA,GAAG,YAAYU,YAAxB;AAAA,SADF,EAGAC,OAJF,CAFwC;;AAQxC,YAAMmG,WAAW,GAAGF,UAAU,CAACH,aAAX,CAAyBC,EAAzB,CAApB,CARwC;;AAUxCA,QAAAA,EAAE,CAAC3B,KAAH,CAASnB,IAAT,CACE3B,YAAY,CAACC,eAAe,CAACC,MAAhB,CAAuB,CAAC,WAAD,CAAvB,EAAsC,CAAC2E,WAAD,CAAtC,CAAD,EAAuD,EAAvD,CADd,EAVwC;;AAcxCJ,QAAAA,EAAE,CAACK,SAAH,CAAanD,IAAb,CAAkB8C,EAAE,CAAC3B,KAAH,CAASvC,MAAT,GAAkB,CAApC;AACD;;AAED,UAAIzB,KAAK,GAAGT,OAAO,CAACiC,IAAR,CAAaxB,KAAzB;AAEA,UAAME,IAAI,GAAG,KAAKmF,gBAAL,CACX9F,OADW,EAEXoG,EAAE,CAACL,aAFQ,EAGXK,EAAE,CAACJ,cAHQ,EAIXI,EAAE,CAAC3B,KAJQ,CAAb;;AAOA,UAAI9D,IAAI,CAACuB,MAAL,GAAc,CAAlB,EAAqB;AACnBzB,QAAAA,KAAK,IAAIH,YAAY,CAACoG,gBAAtB;AACD,OA7BgC;;;AAgCjCN,MAAAA,EAAE,CAACK,SAAH,GAAeL,EAAE,CAACK,SAAH,CAAanC,MAAb,CACb8B,EAAE,CAACO,gBAAH,CAAoBT,GAApB,CAAwBlG,OAAxB,KAAoC,EADvB,CAAf,CAhCiC;;AAqCjC,UAAI4G,GAAG,GAAG,IAAV;;AACA,UAAIR,EAAE,CAACf,iBAAH,CAAqBK,GAArB,CAAyB1F,OAAzB,CAAJ,EAAuC;AAAA;;AACrC,YACEA,OAAO,CAAC8B,IAAR,KAAiBmC,WAAW,CAACkB,OAA7B,IACAnF,OAAO,CAAC8B,IAAR,KAAiBmC,WAAW,CAACgB,OAF/B,EAGE;AACA,gBAAM,IAAIhE,KAAJ,sBACejB,OAAO,CAACiC,IAAR,CAAavB,QAAb,CAAsB0B,IADrC,8DAAN;AAGD;;AACDwE,QAAAA,GAAG,GAAGR,EAAE,CAAC3B,KAAH,CAASvC,MAAf;;AAEA,YAAIkE,EAAE,CAACK,SAAH,CAAavE,MAAb,GAAsB,CAA1B,EAA6B;AAC3B0E,UAAAA,GAAG,GAAGR,EAAE,CAACK,SAAH,CAAaI,GAAb,EAAN;AACD,SAboC;;;AAgBrCT,QAAAA,EAAE,CAACL,aAAH,CAAiBH,GAAjB,CAAqB5F,OAArB,EAA8B4G,GAA9B,EAhBqC;;AAmBrC,YAAME,aAAa,GAAGV,EAAE,CAACf,iBAAH,CAAqBa,GAArB,CAAyBlG,OAAzB,CAAtB;AACAoG,QAAAA,EAAE,CAACO,gBAAH,CAAoBf,GAApB,CACEkB,aADF,EAEE,CAACV,EAAE,CAACO,gBAAH,CAAoBT,GAApB,CAAwBY,aAAxB,KAA0C,EAA3C,EAA+CxC,MAA/C,CAAsD,CAACsC,GAAD,CAAtD,CAFF;;AAKA,YAAIA,GAAG,KAAKR,EAAE,CAAC3B,KAAH,CAASvC,MAArB,EAA6B;AAC3BkE,UAAAA,EAAE,CAAC3B,KAAH,CAASnB,IAAT,CAAc,IAAd;AACD;;AAED,YACE/B,aAAa,0BAACvB,OAAO,CAACiC,IAAR,CAAavB,QAAb,CAAsBmE,OAAvB,qBAAC,sBAAgC,CAAhC,CAAD,CAAb,IACA,CAAC7E,OAAO,CAACiC,IAAR,CAAaxB,KAAb,GAAqBH,YAAY,CAACc,YAAnC,MAAqD,CAFvD,EAGE;AACAwF,UAAAA,GAAG,IAAI,IAAP;AACD;AACF,OAnCD,MAmCO,IACL5G,OAAO,CAAC8B,IAAR,KAAiBmC,WAAW,CAACkB,OAA7B,IACAnF,OAAO,CAAC8B,IAAR,KAAiBmC,WAAW,CAACgB,OAFxB,EAGL;AACA,YACEjF,OAAO,CAACiC,IAAR,CAAavB,QAAb,CAAsBmE,OAAtB,IACA7E,OAAO,CAACiC,IAAR,CAAavB,QAAb,CAAsBmE,OAAtB,CAA8B3C,MAA9B,KAAyC,CAF3C,EAGE;AACA0E,UAAAA,GAAG,GAAG,IAAN;AACD;AACF;;AAED,UACE,CAACnG,KAAK,GAAGH,YAAY,CAACoG,gBAAtB,MACApG,YAAY,CAACoG,gBAFf,EAGE;AACA;AACAL,QAAAA,eAAe,CAAC/C,IAAhB,CACEyD,SAAS,CAAC,CACR/G,OAAO,CAACiC,IAAR,CAAazB,QAAb,cAAgCwG,UAAhC,CAA2ChH,OAAO,CAACiC,IAAR,CAAavB,QAAxD,CADQ,EAER,CAACD,KAAD,EAAQ,CAAR,EAAW,CAAX,EAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,EAA0BmG,GAA1B,CAFQ,EAGR5G,OAAO,CAACiC,IAAR,CAAazB,QAAb,CAAsBkC,OAHd,CAAD,CADX;AAOA2D,QAAAA,eAAe,CAAC/C,IAAhB,CAAqByD,SAAS,CAAC,CAAC5C,QAAQ,CAACxD,IAAD,EAAO,EAAP,EAAW,IAAX,CAAT,CAAD,CAA9B;AACD,OAbD,MAaO;AACL;AACA0F,QAAAA,eAAe,CAAC/C,IAAhB,CACEyD,SAAS,CAAC,CACR/G,OAAO,CAACiC,IAAR,CAAazB,QAAb,cAAgCwG,UAAhC,CAA2ChH,OAAO,CAACiC,IAAR,CAAavB,QAAxD,CADQ,EAER,CAACD,KAAD,CAFQ,EAGR0D,QAAQ,CAACxD,IAAD,EAAO,CAAP,EAAU,IAAV,CAHA,EAIR,CAACiG,GAAD,CAJQ,EAKR5G,OAAO,CAACiC,IAAR,CAAazB,QAAb,CAAsBkC,OALd,CAAD,CADX;AASD;AACF;;AACD,WAAO2D,eAAP;AACD,GA5SH;;AAAA,UA8SEY,IA9SF,GA8SE;AACE;AACA,QAAM3B,iBAAiB,GAAG,IAAI4B,GAAJ,EAA1B;;AAEA,QAAM7B,iBAAiB,GAAG,IAAI6B,GAAJ,EAA1B;AAEA,SAAK9B,OAAL,CAAaC,iBAAb,EAAgCC,iBAAhC;;AAGA,QAAMqB,gBAAgB,GAAG,IAAIO,GAAJ,EAAzB;;AAGA,QAAMlB,cAAc,GAAG,IAAIkB,GAAJ,EAAvB;AAEA,QAAMzC,KAAK,GAAG,IAAIF,KAAJ,EAAd;;AAGAe,IAAAA,iBAAiB,CAACpC,OAAlB,CAA0B,UAACiE,WAAD,EAAcC,OAAd;AACxB,UAAMnB,IAAI,GAAGxB,KAAK,CAACvC,MAAnB;AACAuC,MAAAA,KAAK,CAACnB,IAAN,CAAW8D,OAAX;AACApB,MAAAA,cAAc,CAACJ,GAAf,CAAmBwB,OAAnB,EAA4BnB,IAA5B;AACAU,MAAAA,gBAAgB,CAACf,GAAjB,CACEuB,WADF,EAEE,CAACR,gBAAgB,CAACT,GAAjB,CAAqBiB,WAArB,KAAqC,EAAtC,EAA0C7C,MAA1C,CAAiD,CAAC2B,IAAD,CAAjD,CAFF;AAID,KARD;AAUA,QAAMG,EAAE,GAAiB;AACvBL,MAAAA,aAAa,EAAE,IAAImB,GAAJ,EADQ;AAEvBlB,MAAAA,cAAc,EAAdA,cAFuB;AAGvBS,MAAAA,SAAS,EAAE,IAAIlC,KAAJ,EAHY;AAIvBoC,MAAAA,gBAAgB,EAAhBA,gBAJuB;AAKvBtB,MAAAA,iBAAiB,EAAjBA,iBALuB;AAMvBZ,MAAAA,KAAK,EAALA;AANuB,KAAzB;AASA,QAAI4B,eAAe,GAAG,KAAKF,aAAL,CAAmBC,EAAnB,CAAtB;AAEA,WAAO;AAAE1B,MAAAA,QAAQ,EAAE2B,eAAZ;AAA6B5B,MAAAA,KAAK,EAALA;AAA7B,KAAP;AACD,GArVH;;AAAA;AAAA;;;;"}