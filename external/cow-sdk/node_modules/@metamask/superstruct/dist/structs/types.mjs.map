{"version":3,"file":"types.mjs","sourceRoot":"","sources":["../../src/structs/types.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Infer } from '../struct.js';\nimport { Struct } from '../struct.js';\nimport type {\n  ObjectSchema,\n  ObjectType,\n  AnyStruct,\n  InferStructTuple,\n  UnionToIntersection,\n} from '../utils.js';\nimport { print, run, isObject } from '../utils.js';\nimport { define } from './utilities.js';\n\n/**\n * Ensure that any value passes validation.\n *\n * @returns A struct that will always pass validation.\n */\nexport function any(): Struct<any, null> {\n  return define('any', () => true);\n}\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @param Element - The struct to validate each element in the array against.\n * @returns A new struct that will only accept arrays of the given type.\n */\nexport function array<Type extends Struct<any>>(\n  Element: Type,\n): Struct<Infer<Type>[], Type>;\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @returns A new struct that will accept any array.\n */\nexport function array(): Struct<unknown[], undefined>;\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @param Element - The struct to validate each element in the array against.\n * @returns A new struct that will only accept arrays of the given type.\n */\nexport function array<Type extends Struct<any>>(Element?: Type): any {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [index, arrayValue] of value.entries()) {\n          yield [index, arrayValue, Element];\n        }\n      }\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array value, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a bigint.\n *\n * @returns A new struct that will only accept bigints.\n */\nexport function bigint(): Struct<bigint, null> {\n  return define('bigint', (value) => {\n    return typeof value === 'bigint';\n  });\n}\n\n/**\n * Ensure that a value is a boolean.\n *\n * @returns A new struct that will only accept booleans.\n */\nexport function boolean(): Struct<boolean, null> {\n  return define('boolean', (value) => {\n    return typeof value === 'boolean';\n  });\n}\n\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n *\n * @returns A new struct that will only accept valid `Date` objects.\n */\nexport function date(): Struct<Date, null> {\n  return define('date', (value) => {\n    return (\n      (value instanceof Date && !isNaN(value.getTime())) ||\n      `Expected a valid \\`Date\\` object, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nexport function enums<Type extends number, Values extends readonly Type[]>(\n  values: Values,\n): Struct<Values[number], { [Key in Values[number]]: Key }>;\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nexport function enums<Type extends string, Values extends readonly Type[]>(\n  values: Values,\n): Struct<Values[number], { [Key in Values[number]]: Key }>;\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nexport function enums<\n  Type extends string | number,\n  Values extends readonly Type[],\n>(values: Values): any {\n  const schema: any = {};\n  const description = values.map((value) => print(value)).join();\n\n  for (const key of values) {\n    schema[key] = key;\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n    validator(value) {\n      return (\n        values.includes(value as any) ||\n        `Expected one of \\`${description}\\`, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a function.\n *\n * @returns A new struct that will only accept functions.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function func(): Struct<Function, null> {\n  return define('func', (value) => {\n    return (\n      typeof value === 'function' ||\n      `Expected a function, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is an instance of a specific class.\n *\n * @param Class - The class that the value must be an instance of.\n * @returns A new struct that will only accept instances of the given class.\n */\nexport function instance<Type extends new (...args: any) => any>(\n  Class: Type,\n): Struct<InstanceType<Type>, null> {\n  return define('instance', (value) => {\n    return (\n      value instanceof Class ||\n      `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is an integer.\n *\n * @returns A new struct that will only accept integers.\n */\nexport function integer(): Struct<number, null> {\n  return define('integer', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n      `Expected an integer, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value matches all of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match all of the\n * given structs.\n */\nexport function intersection<First extends AnyStruct, Rest extends AnyStruct[]>(\n  Structs: [First, ...Rest],\n): Struct<\n  Infer<First> & UnionToIntersection<InferStructTuple<Rest>[number]>,\n  null\n> {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    *entries(value, context) {\n      for (const { entries } of Structs) {\n        yield* entries(value, context);\n      }\n    },\n    *validator(value, context) {\n      for (const { validator } of Structs) {\n        yield* validator(value, context);\n      }\n    },\n    *refiner(value, context) {\n      for (const { refiner } of Structs) {\n        yield* refiner(value, context);\n      }\n    },\n  });\n}\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type extends boolean>(\n  constant: Type,\n): Struct<Type, Type>;\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type extends number>(\n  constant: Type,\n): Struct<Type, Type>;\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type extends string>(\n  constant: Type,\n): Struct<Type, Type>;\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type>(constant: Type): Struct<Type, null>;\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal<Type>(constant: Type): any {\n  const description = print(constant);\n  const valueType = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema:\n      valueType === 'string' ||\n      valueType === 'number' ||\n      valueType === 'boolean'\n        ? constant\n        : null,\n\n    validator(value) {\n      return (\n        value === constant ||\n        `Expected the literal \\`${description}\\`, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @returns A new struct that will only accept `Map` objects.\n */\nexport function map(): Struct<Map<unknown, unknown>, null>;\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @param Key - The struct to validate each key in the map against.\n * @param Value - The struct to validate each value in the map against.\n * @returns A new struct that will only accept `Map` objects.\n */\nexport function map<Key, Value>(\n  Key: Struct<Key>,\n  Value: Struct<Value>,\n): Struct<Map<Key, Value>, null>;\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @param Key - The struct to validate each key in the map against.\n * @param Value - The struct to validate each value in the map against.\n * @returns A new struct that will only accept `Map` objects.\n */\nexport function map<Key, Value>(Key?: Struct<Key>, Value?: Struct<Value>): any {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [mapKey, mapValue] of value.entries()) {\n          yield [mapKey as string, mapKey, Key];\n          yield [mapKey as string, mapValue, Value];\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n    validator(value) {\n      return (\n        value instanceof Map ||\n        `Expected a \\`Map\\` object, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that no value ever passes validation.\n *\n * @returns A new struct that will never pass validation.\n */\nexport function never(): Struct<never, null> {\n  return define('never', () => false);\n}\n\n/**\n * Augment an existing struct to allow `null` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `null` values.\n */\nexport function nullable<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type | null, Schema> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n  });\n}\n\n/**\n * Ensure that a value is a number.\n *\n * @returns A new struct that will only accept numbers.\n */\nexport function number(): Struct<number, null> {\n  return define('number', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value)) ||\n      `Expected a number, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @returns A new struct that will only accept objects.\n */\nexport function object(): Struct<Record<string, unknown>, null>;\n\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function object<Schema extends ObjectSchema>(\n  schema: Schema,\n): Struct<ObjectType<Schema>, Schema>;\n\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function object<Schema extends ObjectSchema>(\n  schema?: Schema | undefined,\n): any {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ?? null,\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value));\n\n        for (const key of knowns) {\n          unknowns.delete(key);\n          yield [key, value[key], schema[key] as Struct<any>];\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never];\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      );\n    },\n    coercer(value) {\n      return isObject(value) ? { ...value } : value;\n    },\n  });\n}\n\n/**\n * Augment a struct to allow `undefined` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `undefined` values.\n */\nexport function optional<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type | undefined, Schema> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) =>\n      value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n  });\n}\n\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * @param Key - The struct to validate each key in the record against.\n * @param Value - The struct to validate each value in the record against.\n * @returns A new struct that will only accept objects.\n */\nexport function record<Key extends string, Value>(\n  Key: Struct<Key>,\n  Value: Struct<Value>,\n): Struct<Record<Key, Value>, null> {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    *entries(value) {\n      if (isObject(value)) {\n        // eslint-disable-next-line guard-for-in\n        for (const objectKey in value) {\n          const objectValue = value[objectKey];\n          yield [objectKey, objectKey, Key];\n          yield [objectKey, objectValue, Value];\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n *\n * @returns A new struct that will only accept `RegExp` objects.\n */\nexport function regexp(): Struct<RegExp, null> {\n  return define('regexp', (value) => {\n    return value instanceof RegExp;\n  });\n}\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @returns A new struct that will only accept `Set` objects.\n */\nexport function set(): Struct<Set<unknown>, null>;\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @param Element - The struct to validate each element in the set against.\n * @returns A new struct that will only accept `Set` objects.\n */\nexport function set<Type>(Element: Struct<Type>): Struct<Set<Type>, null>;\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @param Element - The struct to validate each element in the set against.\n * @returns A new struct that will only accept `Set` objects.\n */\nexport function set<Type>(Element?: Struct<Type>): any {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const setValue of value) {\n          yield [setValue as string, setValue, Element];\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n    validator(value) {\n      return (\n        value instanceof Set ||\n        `Expected a \\`Set\\` object, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value is a string.\n *\n * @returns A new struct that will only accept strings.\n */\nexport function string(): Struct<string, null> {\n  return define('string', (value) => {\n    return (\n      typeof value === 'string' ||\n      `Expected a string, but received: ${print(value)}`\n    );\n  });\n}\n\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept tuples of the given types.\n */\nexport function tuple<First extends AnyStruct, Rest extends AnyStruct[]>(\n  Structs: [First, ...Rest],\n): Struct<[Infer<First>, ...InferStructTuple<Rest>], null> {\n  const Never = never();\n\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Structs.length, value.length);\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Structs[i] || Never];\n        }\n      }\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array, but received: ${print(value)}`\n      );\n    },\n  });\n}\n\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function type<Schema extends ObjectSchema>(\n  schema: Schema,\n): Struct<ObjectType<Schema>, Schema> {\n  const keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k] as Struct<any>];\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      );\n    },\n    coercer(value) {\n      return isObject(value) ? { ...value } : value;\n    },\n  });\n}\n\n/**\n * Ensure that a value matches one of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match one of the\n * given structs.\n */\nexport function union<First extends AnyStruct, Rest extends AnyStruct[]>(\n  Structs: [First, ...Rest],\n): Struct<Infer<First> | InferStructTuple<Rest>[number], null> {\n  const description = Structs.map((struct) => struct.type).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n    coercer(value) {\n      for (const InnerStruct of Structs) {\n        const [error, coerced] = InnerStruct.validate(value, { coerce: true });\n        if (!error) {\n          return coerced;\n        }\n      }\n\n      return value;\n    },\n    validator(value, ctx) {\n      const failures = [];\n\n      for (const InnerStruct of Structs) {\n        const [...tuples] = run(value, InnerStruct, ctx);\n        const [first] = tuples;\n\n        if (!first?.[0]) {\n          return [];\n        }\n\n        for (const [failure] of tuples) {\n          if (failure) {\n            failures.push(failure);\n          }\n        }\n      }\n\n      return [\n        `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(\n          value,\n        )}`,\n        ...failures,\n      ];\n    },\n  });\n}\n\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n *\n * @returns A struct that will always pass validation.\n */\nexport function unknown(): Struct<unknown, null> {\n  return define('unknown', () => true);\n}\n"]}